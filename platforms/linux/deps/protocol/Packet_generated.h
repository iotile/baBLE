// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_PACKET_BABLE_H_
#define FLATBUFFERS_GENERATED_PACKET_BABLE_H_

#include "flatbuffers/flatbuffers.h"

namespace BaBLE {

struct Controller;

struct GetControllersList;

struct GetControllersIds;

struct GetControllerInfo;

struct Device;

struct GetConnectedDevices;

struct StartScan;

struct StopScan;

struct Connect;

struct CancelConnection;

struct Disconnect;

struct SetPowered;

struct SetDiscoverable;

struct SetConnectable;

struct ReadCentral;

struct ReadPeripheral;

struct WriteCentral;

struct WritePeripheral;

struct WriteWithoutResponseCentral;

struct WriteWithoutResponsePeripheral;

struct Service;

struct ProbeServices;

struct Characteristic;

struct ProbeCharacteristics;

struct SetAdvertising;

struct EmitNotification;

struct DeviceConnected;

struct DeviceDisconnected;

struct DeviceFound;

struct ControllerAdded;

struct ControllerRemoved;

struct NotificationReceived;

struct BaBLEError;

struct SetGATTTable;

struct Ready;

struct Exit;

struct Packet;

enum class Payload : uint8_t {
  NONE = 0,
  CancelConnection = 1,
  Connect = 2,
  Disconnect = 3,
  EmitNotification = 4,
  GetConnectedDevices = 5,
  GetControllersIds = 6,
  GetControllerInfo = 7,
  GetControllersList = 8,
  ProbeCharacteristics = 9,
  ProbeServices = 10,
  ReadCentral = 11,
  ReadPeripheral = 12,
  SetAdvertising = 13,
  SetConnectable = 14,
  SetDiscoverable = 15,
  SetPowered = 16,
  StartScan = 17,
  StopScan = 18,
  WriteCentral = 19,
  WritePeripheral = 20,
  WriteWithoutResponseCentral = 21,
  WriteWithoutResponsePeripheral = 22,
  ControllerAdded = 23,
  ControllerRemoved = 24,
  DeviceConnected = 25,
  DeviceDisconnected = 26,
  DeviceFound = 27,
  NotificationReceived = 28,
  BaBLEError = 29,
  Exit = 30,
  Ready = 31,
  SetGATTTable = 32,
  MIN = NONE,
  MAX = SetGATTTable
};

inline const Payload (&EnumValuesPayload())[33] {
  static const Payload values[] = {
    Payload::NONE,
    Payload::CancelConnection,
    Payload::Connect,
    Payload::Disconnect,
    Payload::EmitNotification,
    Payload::GetConnectedDevices,
    Payload::GetControllersIds,
    Payload::GetControllerInfo,
    Payload::GetControllersList,
    Payload::ProbeCharacteristics,
    Payload::ProbeServices,
    Payload::ReadCentral,
    Payload::ReadPeripheral,
    Payload::SetAdvertising,
    Payload::SetConnectable,
    Payload::SetDiscoverable,
    Payload::SetPowered,
    Payload::StartScan,
    Payload::StopScan,
    Payload::WriteCentral,
    Payload::WritePeripheral,
    Payload::WriteWithoutResponseCentral,
    Payload::WriteWithoutResponsePeripheral,
    Payload::ControllerAdded,
    Payload::ControllerRemoved,
    Payload::DeviceConnected,
    Payload::DeviceDisconnected,
    Payload::DeviceFound,
    Payload::NotificationReceived,
    Payload::BaBLEError,
    Payload::Exit,
    Payload::Ready,
    Payload::SetGATTTable
  };
  return values;
}

inline const char * const *EnumNamesPayload() {
  static const char * const names[] = {
    "NONE",
    "CancelConnection",
    "Connect",
    "Disconnect",
    "EmitNotification",
    "GetConnectedDevices",
    "GetControllersIds",
    "GetControllerInfo",
    "GetControllersList",
    "ProbeCharacteristics",
    "ProbeServices",
    "ReadCentral",
    "ReadPeripheral",
    "SetAdvertising",
    "SetConnectable",
    "SetDiscoverable",
    "SetPowered",
    "StartScan",
    "StopScan",
    "WriteCentral",
    "WritePeripheral",
    "WriteWithoutResponseCentral",
    "WriteWithoutResponsePeripheral",
    "ControllerAdded",
    "ControllerRemoved",
    "DeviceConnected",
    "DeviceDisconnected",
    "DeviceFound",
    "NotificationReceived",
    "BaBLEError",
    "Exit",
    "Ready",
    "SetGATTTable",
    nullptr
  };
  return names;
}

inline const char *EnumNamePayload(Payload e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesPayload()[index];
}

template<typename T> struct PayloadTraits {
  static const Payload enum_value = Payload::NONE;
};

template<> struct PayloadTraits<CancelConnection> {
  static const Payload enum_value = Payload::CancelConnection;
};

template<> struct PayloadTraits<Connect> {
  static const Payload enum_value = Payload::Connect;
};

template<> struct PayloadTraits<Disconnect> {
  static const Payload enum_value = Payload::Disconnect;
};

template<> struct PayloadTraits<EmitNotification> {
  static const Payload enum_value = Payload::EmitNotification;
};

template<> struct PayloadTraits<GetConnectedDevices> {
  static const Payload enum_value = Payload::GetConnectedDevices;
};

template<> struct PayloadTraits<GetControllersIds> {
  static const Payload enum_value = Payload::GetControllersIds;
};

template<> struct PayloadTraits<GetControllerInfo> {
  static const Payload enum_value = Payload::GetControllerInfo;
};

template<> struct PayloadTraits<GetControllersList> {
  static const Payload enum_value = Payload::GetControllersList;
};

template<> struct PayloadTraits<ProbeCharacteristics> {
  static const Payload enum_value = Payload::ProbeCharacteristics;
};

template<> struct PayloadTraits<ProbeServices> {
  static const Payload enum_value = Payload::ProbeServices;
};

template<> struct PayloadTraits<ReadCentral> {
  static const Payload enum_value = Payload::ReadCentral;
};

template<> struct PayloadTraits<ReadPeripheral> {
  static const Payload enum_value = Payload::ReadPeripheral;
};

template<> struct PayloadTraits<SetAdvertising> {
  static const Payload enum_value = Payload::SetAdvertising;
};

template<> struct PayloadTraits<SetConnectable> {
  static const Payload enum_value = Payload::SetConnectable;
};

template<> struct PayloadTraits<SetDiscoverable> {
  static const Payload enum_value = Payload::SetDiscoverable;
};

template<> struct PayloadTraits<SetPowered> {
  static const Payload enum_value = Payload::SetPowered;
};

template<> struct PayloadTraits<StartScan> {
  static const Payload enum_value = Payload::StartScan;
};

template<> struct PayloadTraits<StopScan> {
  static const Payload enum_value = Payload::StopScan;
};

template<> struct PayloadTraits<WriteCentral> {
  static const Payload enum_value = Payload::WriteCentral;
};

template<> struct PayloadTraits<WritePeripheral> {
  static const Payload enum_value = Payload::WritePeripheral;
};

template<> struct PayloadTraits<WriteWithoutResponseCentral> {
  static const Payload enum_value = Payload::WriteWithoutResponseCentral;
};

template<> struct PayloadTraits<WriteWithoutResponsePeripheral> {
  static const Payload enum_value = Payload::WriteWithoutResponsePeripheral;
};

template<> struct PayloadTraits<ControllerAdded> {
  static const Payload enum_value = Payload::ControllerAdded;
};

template<> struct PayloadTraits<ControllerRemoved> {
  static const Payload enum_value = Payload::ControllerRemoved;
};

template<> struct PayloadTraits<DeviceConnected> {
  static const Payload enum_value = Payload::DeviceConnected;
};

template<> struct PayloadTraits<DeviceDisconnected> {
  static const Payload enum_value = Payload::DeviceDisconnected;
};

template<> struct PayloadTraits<DeviceFound> {
  static const Payload enum_value = Payload::DeviceFound;
};

template<> struct PayloadTraits<NotificationReceived> {
  static const Payload enum_value = Payload::NotificationReceived;
};

template<> struct PayloadTraits<BaBLEError> {
  static const Payload enum_value = Payload::BaBLEError;
};

template<> struct PayloadTraits<Exit> {
  static const Payload enum_value = Payload::Exit;
};

template<> struct PayloadTraits<Ready> {
  static const Payload enum_value = Payload::Ready;
};

template<> struct PayloadTraits<SetGATTTable> {
  static const Payload enum_value = Payload::SetGATTTable;
};

bool VerifyPayload(flatbuffers::Verifier &verifier, const void *obj, Payload type);
bool VerifyPayloadVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class Model : uint8_t {
  NONE = 0,
  Characteristic = 1,
  Controller = 2,
  Device = 3,
  Service = 4,
  MIN = NONE,
  MAX = Service
};

inline const Model (&EnumValuesModel())[5] {
  static const Model values[] = {
    Model::NONE,
    Model::Characteristic,
    Model::Controller,
    Model::Device,
    Model::Service
  };
  return values;
}

inline const char * const *EnumNamesModel() {
  static const char * const names[] = {
    "NONE",
    "Characteristic",
    "Controller",
    "Device",
    "Service",
    nullptr
  };
  return names;
}

inline const char *EnumNameModel(Model e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesModel()[index];
}

template<typename T> struct ModelTraits {
  static const Model enum_value = Model::NONE;
};

template<> struct ModelTraits<Characteristic> {
  static const Model enum_value = Model::Characteristic;
};

template<> struct ModelTraits<Controller> {
  static const Model enum_value = Model::Controller;
};

template<> struct ModelTraits<Device> {
  static const Model enum_value = Model::Device;
};

template<> struct ModelTraits<Service> {
  static const Model enum_value = Model::Service;
};

bool VerifyModel(flatbuffers::Verifier &verifier, const void *obj, Model type);
bool VerifyModelVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class StatusCode : uint8_t {
  Success = 0,
  SocketError = 1,
  NotFound = 2,
  WrongFormat = 3,
  InvalidCommand = 4,
  Unknown = 5,
  Rejected = 6,
  Denied = 7,
  Cancelled = 8,
  NotPowered = 9,
  Failed = 10,
  NotConnected = 11,
  MIN = Success,
  MAX = NotConnected
};

inline const StatusCode (&EnumValuesStatusCode())[12] {
  static const StatusCode values[] = {
    StatusCode::Success,
    StatusCode::SocketError,
    StatusCode::NotFound,
    StatusCode::WrongFormat,
    StatusCode::InvalidCommand,
    StatusCode::Unknown,
    StatusCode::Rejected,
    StatusCode::Denied,
    StatusCode::Cancelled,
    StatusCode::NotPowered,
    StatusCode::Failed,
    StatusCode::NotConnected
  };
  return values;
}

inline const char * const *EnumNamesStatusCode() {
  static const char * const names[] = {
    "Success",
    "SocketError",
    "NotFound",
    "WrongFormat",
    "InvalidCommand",
    "Unknown",
    "Rejected",
    "Denied",
    "Cancelled",
    "NotPowered",
    "Failed",
    "NotConnected",
    nullptr
  };
  return names;
}

inline const char *EnumNameStatusCode(StatusCode e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesStatusCode()[index];
}

struct Controller FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_ADDRESS = 6,
    VT_BT_VERSION = 8,
    VT_POWERED = 10,
    VT_CONNECTABLE = 12,
    VT_DISCOVERABLE = 14,
    VT_LOW_ENERGY = 16,
    VT_ADVERTISING = 18,
    VT_NAME = 20
  };
  uint16_t id() const {
    return GetField<uint16_t>(VT_ID, 0);
  }
  const flatbuffers::String *address() const {
    return GetPointer<const flatbuffers::String *>(VT_ADDRESS);
  }
  uint8_t bt_version() const {
    return GetField<uint8_t>(VT_BT_VERSION, 0);
  }
  bool powered() const {
    return GetField<uint8_t>(VT_POWERED, 0) != 0;
  }
  bool connectable() const {
    return GetField<uint8_t>(VT_CONNECTABLE, 0) != 0;
  }
  bool discoverable() const {
    return GetField<uint8_t>(VT_DISCOVERABLE, 0) != 0;
  }
  bool low_energy() const {
    return GetField<uint8_t>(VT_LOW_ENERGY, 0) != 0;
  }
  bool advertising() const {
    return GetField<uint8_t>(VT_ADVERTISING, 0) != 0;
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ID) &&
           VerifyOffset(verifier, VT_ADDRESS) &&
           verifier.Verify(address()) &&
           VerifyField<uint8_t>(verifier, VT_BT_VERSION) &&
           VerifyField<uint8_t>(verifier, VT_POWERED) &&
           VerifyField<uint8_t>(verifier, VT_CONNECTABLE) &&
           VerifyField<uint8_t>(verifier, VT_DISCOVERABLE) &&
           VerifyField<uint8_t>(verifier, VT_LOW_ENERGY) &&
           VerifyField<uint8_t>(verifier, VT_ADVERTISING) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           verifier.EndTable();
  }
};

struct ControllerBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint16_t id) {
    fbb_.AddElement<uint16_t>(Controller::VT_ID, id, 0);
  }
  void add_address(flatbuffers::Offset<flatbuffers::String> address) {
    fbb_.AddOffset(Controller::VT_ADDRESS, address);
  }
  void add_bt_version(uint8_t bt_version) {
    fbb_.AddElement<uint8_t>(Controller::VT_BT_VERSION, bt_version, 0);
  }
  void add_powered(bool powered) {
    fbb_.AddElement<uint8_t>(Controller::VT_POWERED, static_cast<uint8_t>(powered), 0);
  }
  void add_connectable(bool connectable) {
    fbb_.AddElement<uint8_t>(Controller::VT_CONNECTABLE, static_cast<uint8_t>(connectable), 0);
  }
  void add_discoverable(bool discoverable) {
    fbb_.AddElement<uint8_t>(Controller::VT_DISCOVERABLE, static_cast<uint8_t>(discoverable), 0);
  }
  void add_low_energy(bool low_energy) {
    fbb_.AddElement<uint8_t>(Controller::VT_LOW_ENERGY, static_cast<uint8_t>(low_energy), 0);
  }
  void add_advertising(bool advertising) {
    fbb_.AddElement<uint8_t>(Controller::VT_ADVERTISING, static_cast<uint8_t>(advertising), 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Controller::VT_NAME, name);
  }
  explicit ControllerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ControllerBuilder &operator=(const ControllerBuilder &);
  flatbuffers::Offset<Controller> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Controller>(end);
    return o;
  }
};

inline flatbuffers::Offset<Controller> CreateController(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t id = 0,
    flatbuffers::Offset<flatbuffers::String> address = 0,
    uint8_t bt_version = 0,
    bool powered = false,
    bool connectable = false,
    bool discoverable = false,
    bool low_energy = false,
    bool advertising = false,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  ControllerBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_address(address);
  builder_.add_id(id);
  builder_.add_advertising(advertising);
  builder_.add_low_energy(low_energy);
  builder_.add_discoverable(discoverable);
  builder_.add_connectable(connectable);
  builder_.add_powered(powered);
  builder_.add_bt_version(bt_version);
  return builder_.Finish();
}

inline flatbuffers::Offset<Controller> CreateControllerDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t id = 0,
    const char *address = nullptr,
    uint8_t bt_version = 0,
    bool powered = false,
    bool connectable = false,
    bool discoverable = false,
    bool low_energy = false,
    bool advertising = false,
    const char *name = nullptr) {
  return BaBLE::CreateController(
      _fbb,
      id,
      address ? _fbb.CreateString(address) : 0,
      bt_version,
      powered,
      connectable,
      discoverable,
      low_energy,
      advertising,
      name ? _fbb.CreateString(name) : 0);
}

struct GetControllersList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CONTROLLERS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<Controller>> *controllers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Controller>> *>(VT_CONTROLLERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONTROLLERS) &&
           verifier.Verify(controllers()) &&
           verifier.VerifyVectorOfTables(controllers()) &&
           verifier.EndTable();
  }
};

struct GetControllersListBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_controllers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Controller>>> controllers) {
    fbb_.AddOffset(GetControllersList::VT_CONTROLLERS, controllers);
  }
  explicit GetControllersListBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GetControllersListBuilder &operator=(const GetControllersListBuilder &);
  flatbuffers::Offset<GetControllersList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GetControllersList>(end);
    return o;
  }
};

inline flatbuffers::Offset<GetControllersList> CreateGetControllersList(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Controller>>> controllers = 0) {
  GetControllersListBuilder builder_(_fbb);
  builder_.add_controllers(controllers);
  return builder_.Finish();
}

inline flatbuffers::Offset<GetControllersList> CreateGetControllersListDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Controller>> *controllers = nullptr) {
  return BaBLE::CreateGetControllersList(
      _fbb,
      controllers ? _fbb.CreateVector<flatbuffers::Offset<Controller>>(*controllers) : 0);
}

struct GetControllersIds FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CONTROLLERS_IDS = 4
  };
  const flatbuffers::Vector<uint16_t> *controllers_ids() const {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_CONTROLLERS_IDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONTROLLERS_IDS) &&
           verifier.Verify(controllers_ids()) &&
           verifier.EndTable();
  }
};

struct GetControllersIdsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_controllers_ids(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> controllers_ids) {
    fbb_.AddOffset(GetControllersIds::VT_CONTROLLERS_IDS, controllers_ids);
  }
  explicit GetControllersIdsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GetControllersIdsBuilder &operator=(const GetControllersIdsBuilder &);
  flatbuffers::Offset<GetControllersIds> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GetControllersIds>(end);
    return o;
  }
};

inline flatbuffers::Offset<GetControllersIds> CreateGetControllersIds(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> controllers_ids = 0) {
  GetControllersIdsBuilder builder_(_fbb);
  builder_.add_controllers_ids(controllers_ids);
  return builder_.Finish();
}

inline flatbuffers::Offset<GetControllersIds> CreateGetControllersIdsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint16_t> *controllers_ids = nullptr) {
  return BaBLE::CreateGetControllersIds(
      _fbb,
      controllers_ids ? _fbb.CreateVector<uint16_t>(*controllers_ids) : 0);
}

struct GetControllerInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CONTROLLER_INFO = 4
  };
  const Controller *controller_info() const {
    return GetPointer<const Controller *>(VT_CONTROLLER_INFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONTROLLER_INFO) &&
           verifier.VerifyTable(controller_info()) &&
           verifier.EndTable();
  }
};

struct GetControllerInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_controller_info(flatbuffers::Offset<Controller> controller_info) {
    fbb_.AddOffset(GetControllerInfo::VT_CONTROLLER_INFO, controller_info);
  }
  explicit GetControllerInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GetControllerInfoBuilder &operator=(const GetControllerInfoBuilder &);
  flatbuffers::Offset<GetControllerInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GetControllerInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<GetControllerInfo> CreateGetControllerInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Controller> controller_info = 0) {
  GetControllerInfoBuilder builder_(_fbb);
  builder_.add_controller_info(controller_info);
  return builder_.Finish();
}

struct Device FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CONNECTION_HANDLE = 4,
    VT_ADDRESS = 6
  };
  uint16_t connection_handle() const {
    return GetField<uint16_t>(VT_CONNECTION_HANDLE, 0);
  }
  const flatbuffers::String *address() const {
    return GetPointer<const flatbuffers::String *>(VT_ADDRESS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_CONNECTION_HANDLE) &&
           VerifyOffset(verifier, VT_ADDRESS) &&
           verifier.Verify(address()) &&
           verifier.EndTable();
  }
};

struct DeviceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_connection_handle(uint16_t connection_handle) {
    fbb_.AddElement<uint16_t>(Device::VT_CONNECTION_HANDLE, connection_handle, 0);
  }
  void add_address(flatbuffers::Offset<flatbuffers::String> address) {
    fbb_.AddOffset(Device::VT_ADDRESS, address);
  }
  explicit DeviceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DeviceBuilder &operator=(const DeviceBuilder &);
  flatbuffers::Offset<Device> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Device>(end);
    return o;
  }
};

inline flatbuffers::Offset<Device> CreateDevice(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t connection_handle = 0,
    flatbuffers::Offset<flatbuffers::String> address = 0) {
  DeviceBuilder builder_(_fbb);
  builder_.add_address(address);
  builder_.add_connection_handle(connection_handle);
  return builder_.Finish();
}

inline flatbuffers::Offset<Device> CreateDeviceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t connection_handle = 0,
    const char *address = nullptr) {
  return BaBLE::CreateDevice(
      _fbb,
      connection_handle,
      address ? _fbb.CreateString(address) : 0);
}

struct GetConnectedDevices FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DEVICES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<Device>> *devices() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Device>> *>(VT_DEVICES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DEVICES) &&
           verifier.Verify(devices()) &&
           verifier.VerifyVectorOfTables(devices()) &&
           verifier.EndTable();
  }
};

struct GetConnectedDevicesBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_devices(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Device>>> devices) {
    fbb_.AddOffset(GetConnectedDevices::VT_DEVICES, devices);
  }
  explicit GetConnectedDevicesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GetConnectedDevicesBuilder &operator=(const GetConnectedDevicesBuilder &);
  flatbuffers::Offset<GetConnectedDevices> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GetConnectedDevices>(end);
    return o;
  }
};

inline flatbuffers::Offset<GetConnectedDevices> CreateGetConnectedDevices(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Device>>> devices = 0) {
  GetConnectedDevicesBuilder builder_(_fbb);
  builder_.add_devices(devices);
  return builder_.Finish();
}

inline flatbuffers::Offset<GetConnectedDevices> CreateGetConnectedDevicesDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Device>> *devices = nullptr) {
  return BaBLE::CreateGetConnectedDevices(
      _fbb,
      devices ? _fbb.CreateVector<flatbuffers::Offset<Device>>(*devices) : 0);
}

struct StartScan FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACTIVE_SCAN = 4
  };
  bool active_scan() const {
    return GetField<uint8_t>(VT_ACTIVE_SCAN, 1) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ACTIVE_SCAN) &&
           verifier.EndTable();
  }
};

struct StartScanBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_active_scan(bool active_scan) {
    fbb_.AddElement<uint8_t>(StartScan::VT_ACTIVE_SCAN, static_cast<uint8_t>(active_scan), 1);
  }
  explicit StartScanBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StartScanBuilder &operator=(const StartScanBuilder &);
  flatbuffers::Offset<StartScan> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StartScan>(end);
    return o;
  }
};

inline flatbuffers::Offset<StartScan> CreateStartScan(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool active_scan = true) {
  StartScanBuilder builder_(_fbb);
  builder_.add_active_scan(active_scan);
  return builder_.Finish();
}

struct StopScan FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct StopScanBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit StopScanBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StopScanBuilder &operator=(const StopScanBuilder &);
  flatbuffers::Offset<StopScan> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StopScan>(end);
    return o;
  }
};

inline flatbuffers::Offset<StopScan> CreateStopScan(
    flatbuffers::FlatBufferBuilder &_fbb) {
  StopScanBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Connect FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ADDRESS = 4,
    VT_ADDRESS_TYPE = 6,
    VT_CONNECTION_INTERVAL_MIN = 8,
    VT_CONNECTION_INTERVAL_MAX = 10
  };
  const flatbuffers::String *address() const {
    return GetPointer<const flatbuffers::String *>(VT_ADDRESS);
  }
  uint8_t address_type() const {
    return GetField<uint8_t>(VT_ADDRESS_TYPE, 1);
  }
  float connection_interval_min() const {
    return GetField<float>(VT_CONNECTION_INTERVAL_MIN, 7.5f);
  }
  float connection_interval_max() const {
    return GetField<float>(VT_CONNECTION_INTERVAL_MAX, 30.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ADDRESS) &&
           verifier.Verify(address()) &&
           VerifyField<uint8_t>(verifier, VT_ADDRESS_TYPE) &&
           VerifyField<float>(verifier, VT_CONNECTION_INTERVAL_MIN) &&
           VerifyField<float>(verifier, VT_CONNECTION_INTERVAL_MAX) &&
           verifier.EndTable();
  }
};

struct ConnectBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_address(flatbuffers::Offset<flatbuffers::String> address) {
    fbb_.AddOffset(Connect::VT_ADDRESS, address);
  }
  void add_address_type(uint8_t address_type) {
    fbb_.AddElement<uint8_t>(Connect::VT_ADDRESS_TYPE, address_type, 1);
  }
  void add_connection_interval_min(float connection_interval_min) {
    fbb_.AddElement<float>(Connect::VT_CONNECTION_INTERVAL_MIN, connection_interval_min, 7.5f);
  }
  void add_connection_interval_max(float connection_interval_max) {
    fbb_.AddElement<float>(Connect::VT_CONNECTION_INTERVAL_MAX, connection_interval_max, 30.0f);
  }
  explicit ConnectBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ConnectBuilder &operator=(const ConnectBuilder &);
  flatbuffers::Offset<Connect> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Connect>(end);
    return o;
  }
};

inline flatbuffers::Offset<Connect> CreateConnect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> address = 0,
    uint8_t address_type = 1,
    float connection_interval_min = 7.5f,
    float connection_interval_max = 30.0f) {
  ConnectBuilder builder_(_fbb);
  builder_.add_connection_interval_max(connection_interval_max);
  builder_.add_connection_interval_min(connection_interval_min);
  builder_.add_address(address);
  builder_.add_address_type(address_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Connect> CreateConnectDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *address = nullptr,
    uint8_t address_type = 1,
    float connection_interval_min = 7.5f,
    float connection_interval_max = 30.0f) {
  return BaBLE::CreateConnect(
      _fbb,
      address ? _fbb.CreateString(address) : 0,
      address_type,
      connection_interval_min,
      connection_interval_max);
}

struct CancelConnection FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct CancelConnectionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit CancelConnectionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CancelConnectionBuilder &operator=(const CancelConnectionBuilder &);
  flatbuffers::Offset<CancelConnection> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CancelConnection>(end);
    return o;
  }
};

inline flatbuffers::Offset<CancelConnection> CreateCancelConnection(
    flatbuffers::FlatBufferBuilder &_fbb) {
  CancelConnectionBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Disconnect FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CONNECTION_HANDLE = 4
  };
  uint16_t connection_handle() const {
    return GetField<uint16_t>(VT_CONNECTION_HANDLE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_CONNECTION_HANDLE) &&
           verifier.EndTable();
  }
};

struct DisconnectBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_connection_handle(uint16_t connection_handle) {
    fbb_.AddElement<uint16_t>(Disconnect::VT_CONNECTION_HANDLE, connection_handle, 0);
  }
  explicit DisconnectBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DisconnectBuilder &operator=(const DisconnectBuilder &);
  flatbuffers::Offset<Disconnect> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Disconnect>(end);
    return o;
  }
};

inline flatbuffers::Offset<Disconnect> CreateDisconnect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t connection_handle = 0) {
  DisconnectBuilder builder_(_fbb);
  builder_.add_connection_handle(connection_handle);
  return builder_.Finish();
}

struct SetPowered FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_STATE = 4
  };
  bool state() const {
    return GetField<uint8_t>(VT_STATE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_STATE) &&
           verifier.EndTable();
  }
};

struct SetPoweredBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_state(bool state) {
    fbb_.AddElement<uint8_t>(SetPowered::VT_STATE, static_cast<uint8_t>(state), 0);
  }
  explicit SetPoweredBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SetPoweredBuilder &operator=(const SetPoweredBuilder &);
  flatbuffers::Offset<SetPowered> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SetPowered>(end);
    return o;
  }
};

inline flatbuffers::Offset<SetPowered> CreateSetPowered(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool state = false) {
  SetPoweredBuilder builder_(_fbb);
  builder_.add_state(state);
  return builder_.Finish();
}

struct SetDiscoverable FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_STATE = 4,
    VT_TIMEOUT = 6
  };
  bool state() const {
    return GetField<uint8_t>(VT_STATE, 0) != 0;
  }
  uint16_t timeout() const {
    return GetField<uint16_t>(VT_TIMEOUT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_STATE) &&
           VerifyField<uint16_t>(verifier, VT_TIMEOUT) &&
           verifier.EndTable();
  }
};

struct SetDiscoverableBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_state(bool state) {
    fbb_.AddElement<uint8_t>(SetDiscoverable::VT_STATE, static_cast<uint8_t>(state), 0);
  }
  void add_timeout(uint16_t timeout) {
    fbb_.AddElement<uint16_t>(SetDiscoverable::VT_TIMEOUT, timeout, 0);
  }
  explicit SetDiscoverableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SetDiscoverableBuilder &operator=(const SetDiscoverableBuilder &);
  flatbuffers::Offset<SetDiscoverable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SetDiscoverable>(end);
    return o;
  }
};

inline flatbuffers::Offset<SetDiscoverable> CreateSetDiscoverable(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool state = false,
    uint16_t timeout = 0) {
  SetDiscoverableBuilder builder_(_fbb);
  builder_.add_timeout(timeout);
  builder_.add_state(state);
  return builder_.Finish();
}

struct SetConnectable FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_STATE = 4
  };
  bool state() const {
    return GetField<uint8_t>(VT_STATE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_STATE) &&
           verifier.EndTable();
  }
};

struct SetConnectableBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_state(bool state) {
    fbb_.AddElement<uint8_t>(SetConnectable::VT_STATE, static_cast<uint8_t>(state), 0);
  }
  explicit SetConnectableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SetConnectableBuilder &operator=(const SetConnectableBuilder &);
  flatbuffers::Offset<SetConnectable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SetConnectable>(end);
    return o;
  }
};

inline flatbuffers::Offset<SetConnectable> CreateSetConnectable(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool state = false) {
  SetConnectableBuilder builder_(_fbb);
  builder_.add_state(state);
  return builder_.Finish();
}

struct ReadCentral FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CONNECTION_HANDLE = 4,
    VT_ATTRIBUTE_HANDLE = 6,
    VT_VALUE = 8
  };
  uint16_t connection_handle() const {
    return GetField<uint16_t>(VT_CONNECTION_HANDLE, 0);
  }
  uint16_t attribute_handle() const {
    return GetField<uint16_t>(VT_ATTRIBUTE_HANDLE, 0);
  }
  const flatbuffers::Vector<uint8_t> *value() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_CONNECTION_HANDLE) &&
           VerifyField<uint16_t>(verifier, VT_ATTRIBUTE_HANDLE) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.Verify(value()) &&
           verifier.EndTable();
  }
};

struct ReadCentralBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_connection_handle(uint16_t connection_handle) {
    fbb_.AddElement<uint16_t>(ReadCentral::VT_CONNECTION_HANDLE, connection_handle, 0);
  }
  void add_attribute_handle(uint16_t attribute_handle) {
    fbb_.AddElement<uint16_t>(ReadCentral::VT_ATTRIBUTE_HANDLE, attribute_handle, 0);
  }
  void add_value(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value) {
    fbb_.AddOffset(ReadCentral::VT_VALUE, value);
  }
  explicit ReadCentralBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReadCentralBuilder &operator=(const ReadCentralBuilder &);
  flatbuffers::Offset<ReadCentral> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReadCentral>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReadCentral> CreateReadCentral(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t connection_handle = 0,
    uint16_t attribute_handle = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value = 0) {
  ReadCentralBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_attribute_handle(attribute_handle);
  builder_.add_connection_handle(connection_handle);
  return builder_.Finish();
}

inline flatbuffers::Offset<ReadCentral> CreateReadCentralDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t connection_handle = 0,
    uint16_t attribute_handle = 0,
    const std::vector<uint8_t> *value = nullptr) {
  return BaBLE::CreateReadCentral(
      _fbb,
      connection_handle,
      attribute_handle,
      value ? _fbb.CreateVector<uint8_t>(*value) : 0);
}

struct ReadPeripheral FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CONNECTION_HANDLE = 4,
    VT_ATTRIBUTE_HANDLE = 6,
    VT_VALUE = 8
  };
  uint16_t connection_handle() const {
    return GetField<uint16_t>(VT_CONNECTION_HANDLE, 0);
  }
  uint16_t attribute_handle() const {
    return GetField<uint16_t>(VT_ATTRIBUTE_HANDLE, 0);
  }
  const flatbuffers::Vector<uint8_t> *value() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_CONNECTION_HANDLE) &&
           VerifyField<uint16_t>(verifier, VT_ATTRIBUTE_HANDLE) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.Verify(value()) &&
           verifier.EndTable();
  }
};

struct ReadPeripheralBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_connection_handle(uint16_t connection_handle) {
    fbb_.AddElement<uint16_t>(ReadPeripheral::VT_CONNECTION_HANDLE, connection_handle, 0);
  }
  void add_attribute_handle(uint16_t attribute_handle) {
    fbb_.AddElement<uint16_t>(ReadPeripheral::VT_ATTRIBUTE_HANDLE, attribute_handle, 0);
  }
  void add_value(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value) {
    fbb_.AddOffset(ReadPeripheral::VT_VALUE, value);
  }
  explicit ReadPeripheralBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReadPeripheralBuilder &operator=(const ReadPeripheralBuilder &);
  flatbuffers::Offset<ReadPeripheral> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReadPeripheral>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReadPeripheral> CreateReadPeripheral(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t connection_handle = 0,
    uint16_t attribute_handle = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value = 0) {
  ReadPeripheralBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_attribute_handle(attribute_handle);
  builder_.add_connection_handle(connection_handle);
  return builder_.Finish();
}

inline flatbuffers::Offset<ReadPeripheral> CreateReadPeripheralDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t connection_handle = 0,
    uint16_t attribute_handle = 0,
    const std::vector<uint8_t> *value = nullptr) {
  return BaBLE::CreateReadPeripheral(
      _fbb,
      connection_handle,
      attribute_handle,
      value ? _fbb.CreateVector<uint8_t>(*value) : 0);
}

struct WriteCentral FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CONNECTION_HANDLE = 4,
    VT_ATTRIBUTE_HANDLE = 6,
    VT_VALUE = 8
  };
  uint16_t connection_handle() const {
    return GetField<uint16_t>(VT_CONNECTION_HANDLE, 0);
  }
  uint16_t attribute_handle() const {
    return GetField<uint16_t>(VT_ATTRIBUTE_HANDLE, 0);
  }
  const flatbuffers::Vector<uint8_t> *value() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_CONNECTION_HANDLE) &&
           VerifyField<uint16_t>(verifier, VT_ATTRIBUTE_HANDLE) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.Verify(value()) &&
           verifier.EndTable();
  }
};

struct WriteCentralBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_connection_handle(uint16_t connection_handle) {
    fbb_.AddElement<uint16_t>(WriteCentral::VT_CONNECTION_HANDLE, connection_handle, 0);
  }
  void add_attribute_handle(uint16_t attribute_handle) {
    fbb_.AddElement<uint16_t>(WriteCentral::VT_ATTRIBUTE_HANDLE, attribute_handle, 0);
  }
  void add_value(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value) {
    fbb_.AddOffset(WriteCentral::VT_VALUE, value);
  }
  explicit WriteCentralBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WriteCentralBuilder &operator=(const WriteCentralBuilder &);
  flatbuffers::Offset<WriteCentral> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WriteCentral>(end);
    return o;
  }
};

inline flatbuffers::Offset<WriteCentral> CreateWriteCentral(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t connection_handle = 0,
    uint16_t attribute_handle = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value = 0) {
  WriteCentralBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_attribute_handle(attribute_handle);
  builder_.add_connection_handle(connection_handle);
  return builder_.Finish();
}

inline flatbuffers::Offset<WriteCentral> CreateWriteCentralDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t connection_handle = 0,
    uint16_t attribute_handle = 0,
    const std::vector<uint8_t> *value = nullptr) {
  return BaBLE::CreateWriteCentral(
      _fbb,
      connection_handle,
      attribute_handle,
      value ? _fbb.CreateVector<uint8_t>(*value) : 0);
}

struct WritePeripheral FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CONNECTION_HANDLE = 4,
    VT_ATTRIBUTE_HANDLE = 6,
    VT_VALUE = 8
  };
  uint16_t connection_handle() const {
    return GetField<uint16_t>(VT_CONNECTION_HANDLE, 0);
  }
  uint16_t attribute_handle() const {
    return GetField<uint16_t>(VT_ATTRIBUTE_HANDLE, 0);
  }
  const flatbuffers::Vector<uint8_t> *value() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_CONNECTION_HANDLE) &&
           VerifyField<uint16_t>(verifier, VT_ATTRIBUTE_HANDLE) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.Verify(value()) &&
           verifier.EndTable();
  }
};

struct WritePeripheralBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_connection_handle(uint16_t connection_handle) {
    fbb_.AddElement<uint16_t>(WritePeripheral::VT_CONNECTION_HANDLE, connection_handle, 0);
  }
  void add_attribute_handle(uint16_t attribute_handle) {
    fbb_.AddElement<uint16_t>(WritePeripheral::VT_ATTRIBUTE_HANDLE, attribute_handle, 0);
  }
  void add_value(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value) {
    fbb_.AddOffset(WritePeripheral::VT_VALUE, value);
  }
  explicit WritePeripheralBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WritePeripheralBuilder &operator=(const WritePeripheralBuilder &);
  flatbuffers::Offset<WritePeripheral> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WritePeripheral>(end);
    return o;
  }
};

inline flatbuffers::Offset<WritePeripheral> CreateWritePeripheral(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t connection_handle = 0,
    uint16_t attribute_handle = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value = 0) {
  WritePeripheralBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_attribute_handle(attribute_handle);
  builder_.add_connection_handle(connection_handle);
  return builder_.Finish();
}

inline flatbuffers::Offset<WritePeripheral> CreateWritePeripheralDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t connection_handle = 0,
    uint16_t attribute_handle = 0,
    const std::vector<uint8_t> *value = nullptr) {
  return BaBLE::CreateWritePeripheral(
      _fbb,
      connection_handle,
      attribute_handle,
      value ? _fbb.CreateVector<uint8_t>(*value) : 0);
}

struct WriteWithoutResponseCentral FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CONNECTION_HANDLE = 4,
    VT_ATTRIBUTE_HANDLE = 6,
    VT_VALUE = 8
  };
  uint16_t connection_handle() const {
    return GetField<uint16_t>(VT_CONNECTION_HANDLE, 0);
  }
  uint16_t attribute_handle() const {
    return GetField<uint16_t>(VT_ATTRIBUTE_HANDLE, 0);
  }
  const flatbuffers::Vector<uint8_t> *value() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_CONNECTION_HANDLE) &&
           VerifyField<uint16_t>(verifier, VT_ATTRIBUTE_HANDLE) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.Verify(value()) &&
           verifier.EndTable();
  }
};

struct WriteWithoutResponseCentralBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_connection_handle(uint16_t connection_handle) {
    fbb_.AddElement<uint16_t>(WriteWithoutResponseCentral::VT_CONNECTION_HANDLE, connection_handle, 0);
  }
  void add_attribute_handle(uint16_t attribute_handle) {
    fbb_.AddElement<uint16_t>(WriteWithoutResponseCentral::VT_ATTRIBUTE_HANDLE, attribute_handle, 0);
  }
  void add_value(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value) {
    fbb_.AddOffset(WriteWithoutResponseCentral::VT_VALUE, value);
  }
  explicit WriteWithoutResponseCentralBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WriteWithoutResponseCentralBuilder &operator=(const WriteWithoutResponseCentralBuilder &);
  flatbuffers::Offset<WriteWithoutResponseCentral> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WriteWithoutResponseCentral>(end);
    return o;
  }
};

inline flatbuffers::Offset<WriteWithoutResponseCentral> CreateWriteWithoutResponseCentral(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t connection_handle = 0,
    uint16_t attribute_handle = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value = 0) {
  WriteWithoutResponseCentralBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_attribute_handle(attribute_handle);
  builder_.add_connection_handle(connection_handle);
  return builder_.Finish();
}

inline flatbuffers::Offset<WriteWithoutResponseCentral> CreateWriteWithoutResponseCentralDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t connection_handle = 0,
    uint16_t attribute_handle = 0,
    const std::vector<uint8_t> *value = nullptr) {
  return BaBLE::CreateWriteWithoutResponseCentral(
      _fbb,
      connection_handle,
      attribute_handle,
      value ? _fbb.CreateVector<uint8_t>(*value) : 0);
}

struct WriteWithoutResponsePeripheral FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CONNECTION_HANDLE = 4,
    VT_ATTRIBUTE_HANDLE = 6,
    VT_VALUE = 8
  };
  uint16_t connection_handle() const {
    return GetField<uint16_t>(VT_CONNECTION_HANDLE, 0);
  }
  uint16_t attribute_handle() const {
    return GetField<uint16_t>(VT_ATTRIBUTE_HANDLE, 0);
  }
  const flatbuffers::Vector<uint8_t> *value() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_CONNECTION_HANDLE) &&
           VerifyField<uint16_t>(verifier, VT_ATTRIBUTE_HANDLE) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.Verify(value()) &&
           verifier.EndTable();
  }
};

struct WriteWithoutResponsePeripheralBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_connection_handle(uint16_t connection_handle) {
    fbb_.AddElement<uint16_t>(WriteWithoutResponsePeripheral::VT_CONNECTION_HANDLE, connection_handle, 0);
  }
  void add_attribute_handle(uint16_t attribute_handle) {
    fbb_.AddElement<uint16_t>(WriteWithoutResponsePeripheral::VT_ATTRIBUTE_HANDLE, attribute_handle, 0);
  }
  void add_value(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value) {
    fbb_.AddOffset(WriteWithoutResponsePeripheral::VT_VALUE, value);
  }
  explicit WriteWithoutResponsePeripheralBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WriteWithoutResponsePeripheralBuilder &operator=(const WriteWithoutResponsePeripheralBuilder &);
  flatbuffers::Offset<WriteWithoutResponsePeripheral> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WriteWithoutResponsePeripheral>(end);
    return o;
  }
};

inline flatbuffers::Offset<WriteWithoutResponsePeripheral> CreateWriteWithoutResponsePeripheral(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t connection_handle = 0,
    uint16_t attribute_handle = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value = 0) {
  WriteWithoutResponsePeripheralBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_attribute_handle(attribute_handle);
  builder_.add_connection_handle(connection_handle);
  return builder_.Finish();
}

inline flatbuffers::Offset<WriteWithoutResponsePeripheral> CreateWriteWithoutResponsePeripheralDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t connection_handle = 0,
    uint16_t attribute_handle = 0,
    const std::vector<uint8_t> *value = nullptr) {
  return BaBLE::CreateWriteWithoutResponsePeripheral(
      _fbb,
      connection_handle,
      attribute_handle,
      value ? _fbb.CreateVector<uint8_t>(*value) : 0);
}

struct Service FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_HANDLE = 4,
    VT_GROUP_END_HANDLE = 6,
    VT_UUID = 8
  };
  uint16_t handle() const {
    return GetField<uint16_t>(VT_HANDLE, 0);
  }
  uint16_t group_end_handle() const {
    return GetField<uint16_t>(VT_GROUP_END_HANDLE, 0);
  }
  const flatbuffers::String *uuid() const {
    return GetPointer<const flatbuffers::String *>(VT_UUID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_HANDLE) &&
           VerifyField<uint16_t>(verifier, VT_GROUP_END_HANDLE) &&
           VerifyOffset(verifier, VT_UUID) &&
           verifier.Verify(uuid()) &&
           verifier.EndTable();
  }
};

struct ServiceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_handle(uint16_t handle) {
    fbb_.AddElement<uint16_t>(Service::VT_HANDLE, handle, 0);
  }
  void add_group_end_handle(uint16_t group_end_handle) {
    fbb_.AddElement<uint16_t>(Service::VT_GROUP_END_HANDLE, group_end_handle, 0);
  }
  void add_uuid(flatbuffers::Offset<flatbuffers::String> uuid) {
    fbb_.AddOffset(Service::VT_UUID, uuid);
  }
  explicit ServiceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ServiceBuilder &operator=(const ServiceBuilder &);
  flatbuffers::Offset<Service> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Service>(end);
    return o;
  }
};

inline flatbuffers::Offset<Service> CreateService(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t handle = 0,
    uint16_t group_end_handle = 0,
    flatbuffers::Offset<flatbuffers::String> uuid = 0) {
  ServiceBuilder builder_(_fbb);
  builder_.add_uuid(uuid);
  builder_.add_group_end_handle(group_end_handle);
  builder_.add_handle(handle);
  return builder_.Finish();
}

inline flatbuffers::Offset<Service> CreateServiceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t handle = 0,
    uint16_t group_end_handle = 0,
    const char *uuid = nullptr) {
  return BaBLE::CreateService(
      _fbb,
      handle,
      group_end_handle,
      uuid ? _fbb.CreateString(uuid) : 0);
}

struct ProbeServices FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CONNECTION_HANDLE = 4,
    VT_SERVICES = 6
  };
  uint16_t connection_handle() const {
    return GetField<uint16_t>(VT_CONNECTION_HANDLE, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Service>> *services() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Service>> *>(VT_SERVICES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_CONNECTION_HANDLE) &&
           VerifyOffset(verifier, VT_SERVICES) &&
           verifier.Verify(services()) &&
           verifier.VerifyVectorOfTables(services()) &&
           verifier.EndTable();
  }
};

struct ProbeServicesBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_connection_handle(uint16_t connection_handle) {
    fbb_.AddElement<uint16_t>(ProbeServices::VT_CONNECTION_HANDLE, connection_handle, 0);
  }
  void add_services(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Service>>> services) {
    fbb_.AddOffset(ProbeServices::VT_SERVICES, services);
  }
  explicit ProbeServicesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ProbeServicesBuilder &operator=(const ProbeServicesBuilder &);
  flatbuffers::Offset<ProbeServices> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ProbeServices>(end);
    return o;
  }
};

inline flatbuffers::Offset<ProbeServices> CreateProbeServices(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t connection_handle = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Service>>> services = 0) {
  ProbeServicesBuilder builder_(_fbb);
  builder_.add_services(services);
  builder_.add_connection_handle(connection_handle);
  return builder_.Finish();
}

inline flatbuffers::Offset<ProbeServices> CreateProbeServicesDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t connection_handle = 0,
    const std::vector<flatbuffers::Offset<Service>> *services = nullptr) {
  return BaBLE::CreateProbeServices(
      _fbb,
      connection_handle,
      services ? _fbb.CreateVector<flatbuffers::Offset<Service>>(*services) : 0);
}

struct Characteristic FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_HANDLE = 4,
    VT_VALUE_HANDLE = 6,
    VT_CONFIG_HANDLE = 8,
    VT_INDICATE = 10,
    VT_NOTIFY = 12,
    VT_WRITE = 14,
    VT_READ = 16,
    VT_BROADCAST = 18,
    VT_NOTIFICATION_ENABLED = 20,
    VT_INDICATION_ENABLED = 22,
    VT_UUID = 24,
    VT_CONST_VALUE = 26
  };
  uint16_t handle() const {
    return GetField<uint16_t>(VT_HANDLE, 0);
  }
  uint16_t value_handle() const {
    return GetField<uint16_t>(VT_VALUE_HANDLE, 0);
  }
  uint16_t config_handle() const {
    return GetField<uint16_t>(VT_CONFIG_HANDLE, 0);
  }
  bool indicate() const {
    return GetField<uint8_t>(VT_INDICATE, 0) != 0;
  }
  bool notify() const {
    return GetField<uint8_t>(VT_NOTIFY, 0) != 0;
  }
  bool write() const {
    return GetField<uint8_t>(VT_WRITE, 0) != 0;
  }
  bool read() const {
    return GetField<uint8_t>(VT_READ, 0) != 0;
  }
  bool broadcast() const {
    return GetField<uint8_t>(VT_BROADCAST, 0) != 0;
  }
  bool notification_enabled() const {
    return GetField<uint8_t>(VT_NOTIFICATION_ENABLED, 0) != 0;
  }
  bool indication_enabled() const {
    return GetField<uint8_t>(VT_INDICATION_ENABLED, 0) != 0;
  }
  const flatbuffers::String *uuid() const {
    return GetPointer<const flatbuffers::String *>(VT_UUID);
  }
  const flatbuffers::Vector<uint8_t> *const_value() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_CONST_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_HANDLE) &&
           VerifyField<uint16_t>(verifier, VT_VALUE_HANDLE) &&
           VerifyField<uint16_t>(verifier, VT_CONFIG_HANDLE) &&
           VerifyField<uint8_t>(verifier, VT_INDICATE) &&
           VerifyField<uint8_t>(verifier, VT_NOTIFY) &&
           VerifyField<uint8_t>(verifier, VT_WRITE) &&
           VerifyField<uint8_t>(verifier, VT_READ) &&
           VerifyField<uint8_t>(verifier, VT_BROADCAST) &&
           VerifyField<uint8_t>(verifier, VT_NOTIFICATION_ENABLED) &&
           VerifyField<uint8_t>(verifier, VT_INDICATION_ENABLED) &&
           VerifyOffset(verifier, VT_UUID) &&
           verifier.Verify(uuid()) &&
           VerifyOffset(verifier, VT_CONST_VALUE) &&
           verifier.Verify(const_value()) &&
           verifier.EndTable();
  }
};

struct CharacteristicBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_handle(uint16_t handle) {
    fbb_.AddElement<uint16_t>(Characteristic::VT_HANDLE, handle, 0);
  }
  void add_value_handle(uint16_t value_handle) {
    fbb_.AddElement<uint16_t>(Characteristic::VT_VALUE_HANDLE, value_handle, 0);
  }
  void add_config_handle(uint16_t config_handle) {
    fbb_.AddElement<uint16_t>(Characteristic::VT_CONFIG_HANDLE, config_handle, 0);
  }
  void add_indicate(bool indicate) {
    fbb_.AddElement<uint8_t>(Characteristic::VT_INDICATE, static_cast<uint8_t>(indicate), 0);
  }
  void add_notify(bool notify) {
    fbb_.AddElement<uint8_t>(Characteristic::VT_NOTIFY, static_cast<uint8_t>(notify), 0);
  }
  void add_write(bool write) {
    fbb_.AddElement<uint8_t>(Characteristic::VT_WRITE, static_cast<uint8_t>(write), 0);
  }
  void add_read(bool read) {
    fbb_.AddElement<uint8_t>(Characteristic::VT_READ, static_cast<uint8_t>(read), 0);
  }
  void add_broadcast(bool broadcast) {
    fbb_.AddElement<uint8_t>(Characteristic::VT_BROADCAST, static_cast<uint8_t>(broadcast), 0);
  }
  void add_notification_enabled(bool notification_enabled) {
    fbb_.AddElement<uint8_t>(Characteristic::VT_NOTIFICATION_ENABLED, static_cast<uint8_t>(notification_enabled), 0);
  }
  void add_indication_enabled(bool indication_enabled) {
    fbb_.AddElement<uint8_t>(Characteristic::VT_INDICATION_ENABLED, static_cast<uint8_t>(indication_enabled), 0);
  }
  void add_uuid(flatbuffers::Offset<flatbuffers::String> uuid) {
    fbb_.AddOffset(Characteristic::VT_UUID, uuid);
  }
  void add_const_value(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> const_value) {
    fbb_.AddOffset(Characteristic::VT_CONST_VALUE, const_value);
  }
  explicit CharacteristicBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CharacteristicBuilder &operator=(const CharacteristicBuilder &);
  flatbuffers::Offset<Characteristic> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Characteristic>(end);
    return o;
  }
};

inline flatbuffers::Offset<Characteristic> CreateCharacteristic(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t handle = 0,
    uint16_t value_handle = 0,
    uint16_t config_handle = 0,
    bool indicate = false,
    bool notify = false,
    bool write = false,
    bool read = false,
    bool broadcast = false,
    bool notification_enabled = false,
    bool indication_enabled = false,
    flatbuffers::Offset<flatbuffers::String> uuid = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> const_value = 0) {
  CharacteristicBuilder builder_(_fbb);
  builder_.add_const_value(const_value);
  builder_.add_uuid(uuid);
  builder_.add_config_handle(config_handle);
  builder_.add_value_handle(value_handle);
  builder_.add_handle(handle);
  builder_.add_indication_enabled(indication_enabled);
  builder_.add_notification_enabled(notification_enabled);
  builder_.add_broadcast(broadcast);
  builder_.add_read(read);
  builder_.add_write(write);
  builder_.add_notify(notify);
  builder_.add_indicate(indicate);
  return builder_.Finish();
}

inline flatbuffers::Offset<Characteristic> CreateCharacteristicDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t handle = 0,
    uint16_t value_handle = 0,
    uint16_t config_handle = 0,
    bool indicate = false,
    bool notify = false,
    bool write = false,
    bool read = false,
    bool broadcast = false,
    bool notification_enabled = false,
    bool indication_enabled = false,
    const char *uuid = nullptr,
    const std::vector<uint8_t> *const_value = nullptr) {
  return BaBLE::CreateCharacteristic(
      _fbb,
      handle,
      value_handle,
      config_handle,
      indicate,
      notify,
      write,
      read,
      broadcast,
      notification_enabled,
      indication_enabled,
      uuid ? _fbb.CreateString(uuid) : 0,
      const_value ? _fbb.CreateVector<uint8_t>(*const_value) : 0);
}

struct ProbeCharacteristics FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CONNECTION_HANDLE = 4,
    VT_START_HANDLE = 6,
    VT_END_HANDLE = 8,
    VT_CHARACTERISTICS = 10
  };
  uint16_t connection_handle() const {
    return GetField<uint16_t>(VT_CONNECTION_HANDLE, 0);
  }
  uint16_t start_handle() const {
    return GetField<uint16_t>(VT_START_HANDLE, 1);
  }
  uint16_t end_handle() const {
    return GetField<uint16_t>(VT_END_HANDLE, 65535);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Characteristic>> *characteristics() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Characteristic>> *>(VT_CHARACTERISTICS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_CONNECTION_HANDLE) &&
           VerifyField<uint16_t>(verifier, VT_START_HANDLE) &&
           VerifyField<uint16_t>(verifier, VT_END_HANDLE) &&
           VerifyOffset(verifier, VT_CHARACTERISTICS) &&
           verifier.Verify(characteristics()) &&
           verifier.VerifyVectorOfTables(characteristics()) &&
           verifier.EndTable();
  }
};

struct ProbeCharacteristicsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_connection_handle(uint16_t connection_handle) {
    fbb_.AddElement<uint16_t>(ProbeCharacteristics::VT_CONNECTION_HANDLE, connection_handle, 0);
  }
  void add_start_handle(uint16_t start_handle) {
    fbb_.AddElement<uint16_t>(ProbeCharacteristics::VT_START_HANDLE, start_handle, 1);
  }
  void add_end_handle(uint16_t end_handle) {
    fbb_.AddElement<uint16_t>(ProbeCharacteristics::VT_END_HANDLE, end_handle, 65535);
  }
  void add_characteristics(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Characteristic>>> characteristics) {
    fbb_.AddOffset(ProbeCharacteristics::VT_CHARACTERISTICS, characteristics);
  }
  explicit ProbeCharacteristicsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ProbeCharacteristicsBuilder &operator=(const ProbeCharacteristicsBuilder &);
  flatbuffers::Offset<ProbeCharacteristics> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ProbeCharacteristics>(end);
    return o;
  }
};

inline flatbuffers::Offset<ProbeCharacteristics> CreateProbeCharacteristics(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t connection_handle = 0,
    uint16_t start_handle = 1,
    uint16_t end_handle = 65535,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Characteristic>>> characteristics = 0) {
  ProbeCharacteristicsBuilder builder_(_fbb);
  builder_.add_characteristics(characteristics);
  builder_.add_end_handle(end_handle);
  builder_.add_start_handle(start_handle);
  builder_.add_connection_handle(connection_handle);
  return builder_.Finish();
}

inline flatbuffers::Offset<ProbeCharacteristics> CreateProbeCharacteristicsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t connection_handle = 0,
    uint16_t start_handle = 1,
    uint16_t end_handle = 65535,
    const std::vector<flatbuffers::Offset<Characteristic>> *characteristics = nullptr) {
  return BaBLE::CreateProbeCharacteristics(
      _fbb,
      connection_handle,
      start_handle,
      end_handle,
      characteristics ? _fbb.CreateVector<flatbuffers::Offset<Characteristic>>(*characteristics) : 0);
}

struct SetAdvertising FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_STATE = 4,
    VT_UUIDS = 6,
    VT_NAME = 8,
    VT_COMPANY_ID = 10,
    VT_ADV_MANUFACTURER_DATA = 12,
    VT_SCAN_MANUFACTURER_DATA = 14
  };
  bool state() const {
    return GetField<uint8_t>(VT_STATE, 0) != 0;
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *uuids() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_UUIDS);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  uint16_t company_id() const {
    return GetField<uint16_t>(VT_COMPANY_ID, 0);
  }
  const flatbuffers::Vector<uint8_t> *adv_manufacturer_data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_ADV_MANUFACTURER_DATA);
  }
  const flatbuffers::Vector<uint8_t> *scan_manufacturer_data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_SCAN_MANUFACTURER_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_STATE) &&
           VerifyOffset(verifier, VT_UUIDS) &&
           verifier.Verify(uuids()) &&
           verifier.VerifyVectorOfStrings(uuids()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<uint16_t>(verifier, VT_COMPANY_ID) &&
           VerifyOffset(verifier, VT_ADV_MANUFACTURER_DATA) &&
           verifier.Verify(adv_manufacturer_data()) &&
           VerifyOffset(verifier, VT_SCAN_MANUFACTURER_DATA) &&
           verifier.Verify(scan_manufacturer_data()) &&
           verifier.EndTable();
  }
};

struct SetAdvertisingBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_state(bool state) {
    fbb_.AddElement<uint8_t>(SetAdvertising::VT_STATE, static_cast<uint8_t>(state), 0);
  }
  void add_uuids(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> uuids) {
    fbb_.AddOffset(SetAdvertising::VT_UUIDS, uuids);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(SetAdvertising::VT_NAME, name);
  }
  void add_company_id(uint16_t company_id) {
    fbb_.AddElement<uint16_t>(SetAdvertising::VT_COMPANY_ID, company_id, 0);
  }
  void add_adv_manufacturer_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> adv_manufacturer_data) {
    fbb_.AddOffset(SetAdvertising::VT_ADV_MANUFACTURER_DATA, adv_manufacturer_data);
  }
  void add_scan_manufacturer_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> scan_manufacturer_data) {
    fbb_.AddOffset(SetAdvertising::VT_SCAN_MANUFACTURER_DATA, scan_manufacturer_data);
  }
  explicit SetAdvertisingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SetAdvertisingBuilder &operator=(const SetAdvertisingBuilder &);
  flatbuffers::Offset<SetAdvertising> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SetAdvertising>(end);
    return o;
  }
};

inline flatbuffers::Offset<SetAdvertising> CreateSetAdvertising(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool state = false,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> uuids = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint16_t company_id = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> adv_manufacturer_data = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> scan_manufacturer_data = 0) {
  SetAdvertisingBuilder builder_(_fbb);
  builder_.add_scan_manufacturer_data(scan_manufacturer_data);
  builder_.add_adv_manufacturer_data(adv_manufacturer_data);
  builder_.add_name(name);
  builder_.add_uuids(uuids);
  builder_.add_company_id(company_id);
  builder_.add_state(state);
  return builder_.Finish();
}

inline flatbuffers::Offset<SetAdvertising> CreateSetAdvertisingDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool state = false,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *uuids = nullptr,
    const char *name = nullptr,
    uint16_t company_id = 0,
    const std::vector<uint8_t> *adv_manufacturer_data = nullptr,
    const std::vector<uint8_t> *scan_manufacturer_data = nullptr) {
  return BaBLE::CreateSetAdvertising(
      _fbb,
      state,
      uuids ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*uuids) : 0,
      name ? _fbb.CreateString(name) : 0,
      company_id,
      adv_manufacturer_data ? _fbb.CreateVector<uint8_t>(*adv_manufacturer_data) : 0,
      scan_manufacturer_data ? _fbb.CreateVector<uint8_t>(*scan_manufacturer_data) : 0);
}

struct EmitNotification FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CONNECTION_HANDLE = 4,
    VT_ATTRIBUTE_HANDLE = 6,
    VT_VALUE = 8
  };
  uint16_t connection_handle() const {
    return GetField<uint16_t>(VT_CONNECTION_HANDLE, 0);
  }
  uint16_t attribute_handle() const {
    return GetField<uint16_t>(VT_ATTRIBUTE_HANDLE, 0);
  }
  const flatbuffers::Vector<uint8_t> *value() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_CONNECTION_HANDLE) &&
           VerifyField<uint16_t>(verifier, VT_ATTRIBUTE_HANDLE) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.Verify(value()) &&
           verifier.EndTable();
  }
};

struct EmitNotificationBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_connection_handle(uint16_t connection_handle) {
    fbb_.AddElement<uint16_t>(EmitNotification::VT_CONNECTION_HANDLE, connection_handle, 0);
  }
  void add_attribute_handle(uint16_t attribute_handle) {
    fbb_.AddElement<uint16_t>(EmitNotification::VT_ATTRIBUTE_HANDLE, attribute_handle, 0);
  }
  void add_value(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value) {
    fbb_.AddOffset(EmitNotification::VT_VALUE, value);
  }
  explicit EmitNotificationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EmitNotificationBuilder &operator=(const EmitNotificationBuilder &);
  flatbuffers::Offset<EmitNotification> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EmitNotification>(end);
    return o;
  }
};

inline flatbuffers::Offset<EmitNotification> CreateEmitNotification(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t connection_handle = 0,
    uint16_t attribute_handle = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value = 0) {
  EmitNotificationBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_attribute_handle(attribute_handle);
  builder_.add_connection_handle(connection_handle);
  return builder_.Finish();
}

inline flatbuffers::Offset<EmitNotification> CreateEmitNotificationDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t connection_handle = 0,
    uint16_t attribute_handle = 0,
    const std::vector<uint8_t> *value = nullptr) {
  return BaBLE::CreateEmitNotification(
      _fbb,
      connection_handle,
      attribute_handle,
      value ? _fbb.CreateVector<uint8_t>(*value) : 0);
}

struct DeviceConnected FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CONNECTION_HANDLE = 4,
    VT_ADDRESS = 6,
    VT_ADDRESS_TYPE = 8
  };
  uint16_t connection_handle() const {
    return GetField<uint16_t>(VT_CONNECTION_HANDLE, 0);
  }
  const flatbuffers::String *address() const {
    return GetPointer<const flatbuffers::String *>(VT_ADDRESS);
  }
  uint8_t address_type() const {
    return GetField<uint8_t>(VT_ADDRESS_TYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_CONNECTION_HANDLE) &&
           VerifyOffset(verifier, VT_ADDRESS) &&
           verifier.Verify(address()) &&
           VerifyField<uint8_t>(verifier, VT_ADDRESS_TYPE) &&
           verifier.EndTable();
  }
};

struct DeviceConnectedBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_connection_handle(uint16_t connection_handle) {
    fbb_.AddElement<uint16_t>(DeviceConnected::VT_CONNECTION_HANDLE, connection_handle, 0);
  }
  void add_address(flatbuffers::Offset<flatbuffers::String> address) {
    fbb_.AddOffset(DeviceConnected::VT_ADDRESS, address);
  }
  void add_address_type(uint8_t address_type) {
    fbb_.AddElement<uint8_t>(DeviceConnected::VT_ADDRESS_TYPE, address_type, 0);
  }
  explicit DeviceConnectedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DeviceConnectedBuilder &operator=(const DeviceConnectedBuilder &);
  flatbuffers::Offset<DeviceConnected> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DeviceConnected>(end);
    return o;
  }
};

inline flatbuffers::Offset<DeviceConnected> CreateDeviceConnected(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t connection_handle = 0,
    flatbuffers::Offset<flatbuffers::String> address = 0,
    uint8_t address_type = 0) {
  DeviceConnectedBuilder builder_(_fbb);
  builder_.add_address(address);
  builder_.add_connection_handle(connection_handle);
  builder_.add_address_type(address_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<DeviceConnected> CreateDeviceConnectedDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t connection_handle = 0,
    const char *address = nullptr,
    uint8_t address_type = 0) {
  return BaBLE::CreateDeviceConnected(
      _fbb,
      connection_handle,
      address ? _fbb.CreateString(address) : 0,
      address_type);
}

struct DeviceDisconnected FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CONNECTION_HANDLE = 4,
    VT_REASON = 6,
    VT_CODE = 8
  };
  uint16_t connection_handle() const {
    return GetField<uint16_t>(VT_CONNECTION_HANDLE, 0);
  }
  const flatbuffers::String *reason() const {
    return GetPointer<const flatbuffers::String *>(VT_REASON);
  }
  uint8_t code() const {
    return GetField<uint8_t>(VT_CODE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_CONNECTION_HANDLE) &&
           VerifyOffset(verifier, VT_REASON) &&
           verifier.Verify(reason()) &&
           VerifyField<uint8_t>(verifier, VT_CODE) &&
           verifier.EndTable();
  }
};

struct DeviceDisconnectedBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_connection_handle(uint16_t connection_handle) {
    fbb_.AddElement<uint16_t>(DeviceDisconnected::VT_CONNECTION_HANDLE, connection_handle, 0);
  }
  void add_reason(flatbuffers::Offset<flatbuffers::String> reason) {
    fbb_.AddOffset(DeviceDisconnected::VT_REASON, reason);
  }
  void add_code(uint8_t code) {
    fbb_.AddElement<uint8_t>(DeviceDisconnected::VT_CODE, code, 0);
  }
  explicit DeviceDisconnectedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DeviceDisconnectedBuilder &operator=(const DeviceDisconnectedBuilder &);
  flatbuffers::Offset<DeviceDisconnected> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DeviceDisconnected>(end);
    return o;
  }
};

inline flatbuffers::Offset<DeviceDisconnected> CreateDeviceDisconnected(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t connection_handle = 0,
    flatbuffers::Offset<flatbuffers::String> reason = 0,
    uint8_t code = 0) {
  DeviceDisconnectedBuilder builder_(_fbb);
  builder_.add_reason(reason);
  builder_.add_connection_handle(connection_handle);
  builder_.add_code(code);
  return builder_.Finish();
}

inline flatbuffers::Offset<DeviceDisconnected> CreateDeviceDisconnectedDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t connection_handle = 0,
    const char *reason = nullptr,
    uint8_t code = 0) {
  return BaBLE::CreateDeviceDisconnected(
      _fbb,
      connection_handle,
      reason ? _fbb.CreateString(reason) : 0,
      code);
}

struct DeviceFound FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4,
    VT_ADDRESS = 6,
    VT_ADDRESS_TYPE = 8,
    VT_RSSI = 10,
    VT_UUID = 12,
    VT_COMPANY_ID = 14,
    VT_MANUFACTURER_DATA = 16,
    VT_DEVICE_NAME = 18
  };
  uint8_t type() const {
    return GetField<uint8_t>(VT_TYPE, 0);
  }
  const flatbuffers::String *address() const {
    return GetPointer<const flatbuffers::String *>(VT_ADDRESS);
  }
  uint8_t address_type() const {
    return GetField<uint8_t>(VT_ADDRESS_TYPE, 0);
  }
  int8_t rssi() const {
    return GetField<int8_t>(VT_RSSI, 0);
  }
  const flatbuffers::String *uuid() const {
    return GetPointer<const flatbuffers::String *>(VT_UUID);
  }
  uint16_t company_id() const {
    return GetField<uint16_t>(VT_COMPANY_ID, 0);
  }
  const flatbuffers::Vector<uint8_t> *manufacturer_data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_MANUFACTURER_DATA);
  }
  const flatbuffers::String *device_name() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICE_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ADDRESS) &&
           verifier.Verify(address()) &&
           VerifyField<uint8_t>(verifier, VT_ADDRESS_TYPE) &&
           VerifyField<int8_t>(verifier, VT_RSSI) &&
           VerifyOffset(verifier, VT_UUID) &&
           verifier.Verify(uuid()) &&
           VerifyField<uint16_t>(verifier, VT_COMPANY_ID) &&
           VerifyOffset(verifier, VT_MANUFACTURER_DATA) &&
           verifier.Verify(manufacturer_data()) &&
           VerifyOffset(verifier, VT_DEVICE_NAME) &&
           verifier.Verify(device_name()) &&
           verifier.EndTable();
  }
};

struct DeviceFoundBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(uint8_t type) {
    fbb_.AddElement<uint8_t>(DeviceFound::VT_TYPE, type, 0);
  }
  void add_address(flatbuffers::Offset<flatbuffers::String> address) {
    fbb_.AddOffset(DeviceFound::VT_ADDRESS, address);
  }
  void add_address_type(uint8_t address_type) {
    fbb_.AddElement<uint8_t>(DeviceFound::VT_ADDRESS_TYPE, address_type, 0);
  }
  void add_rssi(int8_t rssi) {
    fbb_.AddElement<int8_t>(DeviceFound::VT_RSSI, rssi, 0);
  }
  void add_uuid(flatbuffers::Offset<flatbuffers::String> uuid) {
    fbb_.AddOffset(DeviceFound::VT_UUID, uuid);
  }
  void add_company_id(uint16_t company_id) {
    fbb_.AddElement<uint16_t>(DeviceFound::VT_COMPANY_ID, company_id, 0);
  }
  void add_manufacturer_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> manufacturer_data) {
    fbb_.AddOffset(DeviceFound::VT_MANUFACTURER_DATA, manufacturer_data);
  }
  void add_device_name(flatbuffers::Offset<flatbuffers::String> device_name) {
    fbb_.AddOffset(DeviceFound::VT_DEVICE_NAME, device_name);
  }
  explicit DeviceFoundBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DeviceFoundBuilder &operator=(const DeviceFoundBuilder &);
  flatbuffers::Offset<DeviceFound> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DeviceFound>(end);
    return o;
  }
};

inline flatbuffers::Offset<DeviceFound> CreateDeviceFound(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t type = 0,
    flatbuffers::Offset<flatbuffers::String> address = 0,
    uint8_t address_type = 0,
    int8_t rssi = 0,
    flatbuffers::Offset<flatbuffers::String> uuid = 0,
    uint16_t company_id = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> manufacturer_data = 0,
    flatbuffers::Offset<flatbuffers::String> device_name = 0) {
  DeviceFoundBuilder builder_(_fbb);
  builder_.add_device_name(device_name);
  builder_.add_manufacturer_data(manufacturer_data);
  builder_.add_uuid(uuid);
  builder_.add_address(address);
  builder_.add_company_id(company_id);
  builder_.add_rssi(rssi);
  builder_.add_address_type(address_type);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<DeviceFound> CreateDeviceFoundDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t type = 0,
    const char *address = nullptr,
    uint8_t address_type = 0,
    int8_t rssi = 0,
    const char *uuid = nullptr,
    uint16_t company_id = 0,
    const std::vector<uint8_t> *manufacturer_data = nullptr,
    const char *device_name = nullptr) {
  return BaBLE::CreateDeviceFound(
      _fbb,
      type,
      address ? _fbb.CreateString(address) : 0,
      address_type,
      rssi,
      uuid ? _fbb.CreateString(uuid) : 0,
      company_id,
      manufacturer_data ? _fbb.CreateVector<uint8_t>(*manufacturer_data) : 0,
      device_name ? _fbb.CreateString(device_name) : 0);
}

struct ControllerAdded FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ControllerAddedBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ControllerAddedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ControllerAddedBuilder &operator=(const ControllerAddedBuilder &);
  flatbuffers::Offset<ControllerAdded> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ControllerAdded>(end);
    return o;
  }
};

inline flatbuffers::Offset<ControllerAdded> CreateControllerAdded(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ControllerAddedBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ControllerRemoved FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ControllerRemovedBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ControllerRemovedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ControllerRemovedBuilder &operator=(const ControllerRemovedBuilder &);
  flatbuffers::Offset<ControllerRemoved> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ControllerRemoved>(end);
    return o;
  }
};

inline flatbuffers::Offset<ControllerRemoved> CreateControllerRemoved(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ControllerRemovedBuilder builder_(_fbb);
  return builder_.Finish();
}

struct NotificationReceived FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CONNECTION_HANDLE = 4,
    VT_ATTRIBUTE_HANDLE = 6,
    VT_VALUE = 8
  };
  uint16_t connection_handle() const {
    return GetField<uint16_t>(VT_CONNECTION_HANDLE, 0);
  }
  uint16_t attribute_handle() const {
    return GetField<uint16_t>(VT_ATTRIBUTE_HANDLE, 0);
  }
  const flatbuffers::Vector<uint8_t> *value() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_CONNECTION_HANDLE) &&
           VerifyField<uint16_t>(verifier, VT_ATTRIBUTE_HANDLE) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.Verify(value()) &&
           verifier.EndTable();
  }
};

struct NotificationReceivedBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_connection_handle(uint16_t connection_handle) {
    fbb_.AddElement<uint16_t>(NotificationReceived::VT_CONNECTION_HANDLE, connection_handle, 0);
  }
  void add_attribute_handle(uint16_t attribute_handle) {
    fbb_.AddElement<uint16_t>(NotificationReceived::VT_ATTRIBUTE_HANDLE, attribute_handle, 0);
  }
  void add_value(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value) {
    fbb_.AddOffset(NotificationReceived::VT_VALUE, value);
  }
  explicit NotificationReceivedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NotificationReceivedBuilder &operator=(const NotificationReceivedBuilder &);
  flatbuffers::Offset<NotificationReceived> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NotificationReceived>(end);
    return o;
  }
};

inline flatbuffers::Offset<NotificationReceived> CreateNotificationReceived(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t connection_handle = 0,
    uint16_t attribute_handle = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value = 0) {
  NotificationReceivedBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_attribute_handle(attribute_handle);
  builder_.add_connection_handle(connection_handle);
  return builder_.Finish();
}

inline flatbuffers::Offset<NotificationReceived> CreateNotificationReceivedDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t connection_handle = 0,
    uint16_t attribute_handle = 0,
    const std::vector<uint8_t> *value = nullptr) {
  return BaBLE::CreateNotificationReceived(
      _fbb,
      connection_handle,
      attribute_handle,
      value ? _fbb.CreateVector<uint8_t>(*value) : 0);
}

struct BaBLEError FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MESSAGE = 4
  };
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.Verify(message()) &&
           verifier.EndTable();
  }
};

struct BaBLEErrorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(BaBLEError::VT_MESSAGE, message);
  }
  explicit BaBLEErrorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BaBLEErrorBuilder &operator=(const BaBLEErrorBuilder &);
  flatbuffers::Offset<BaBLEError> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BaBLEError>(end);
    return o;
  }
};

inline flatbuffers::Offset<BaBLEError> CreateBaBLEError(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> message = 0) {
  BaBLEErrorBuilder builder_(_fbb);
  builder_.add_message(message);
  return builder_.Finish();
}

inline flatbuffers::Offset<BaBLEError> CreateBaBLEErrorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *message = nullptr) {
  return BaBLE::CreateBaBLEError(
      _fbb,
      message ? _fbb.CreateString(message) : 0);
}

struct SetGATTTable FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SERVICES = 4,
    VT_CHARACTERISTICS = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<Service>> *services() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Service>> *>(VT_SERVICES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Characteristic>> *characteristics() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Characteristic>> *>(VT_CHARACTERISTICS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SERVICES) &&
           verifier.Verify(services()) &&
           verifier.VerifyVectorOfTables(services()) &&
           VerifyOffset(verifier, VT_CHARACTERISTICS) &&
           verifier.Verify(characteristics()) &&
           verifier.VerifyVectorOfTables(characteristics()) &&
           verifier.EndTable();
  }
};

struct SetGATTTableBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_services(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Service>>> services) {
    fbb_.AddOffset(SetGATTTable::VT_SERVICES, services);
  }
  void add_characteristics(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Characteristic>>> characteristics) {
    fbb_.AddOffset(SetGATTTable::VT_CHARACTERISTICS, characteristics);
  }
  explicit SetGATTTableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SetGATTTableBuilder &operator=(const SetGATTTableBuilder &);
  flatbuffers::Offset<SetGATTTable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SetGATTTable>(end);
    return o;
  }
};

inline flatbuffers::Offset<SetGATTTable> CreateSetGATTTable(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Service>>> services = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Characteristic>>> characteristics = 0) {
  SetGATTTableBuilder builder_(_fbb);
  builder_.add_characteristics(characteristics);
  builder_.add_services(services);
  return builder_.Finish();
}

inline flatbuffers::Offset<SetGATTTable> CreateSetGATTTableDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Service>> *services = nullptr,
    const std::vector<flatbuffers::Offset<Characteristic>> *characteristics = nullptr) {
  return BaBLE::CreateSetGATTTable(
      _fbb,
      services ? _fbb.CreateVector<flatbuffers::Offset<Service>>(*services) : 0,
      characteristics ? _fbb.CreateVector<flatbuffers::Offset<Characteristic>>(*characteristics) : 0);
}

struct Ready FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ReadyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ReadyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReadyBuilder &operator=(const ReadyBuilder &);
  flatbuffers::Offset<Ready> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Ready>(end);
    return o;
  }
};

inline flatbuffers::Offset<Ready> CreateReady(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ReadyBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Exit FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ExitBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ExitBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ExitBuilder &operator=(const ExitBuilder &);
  flatbuffers::Offset<Exit> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Exit>(end);
    return o;
  }
};

inline flatbuffers::Offset<Exit> CreateExit(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ExitBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Packet FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_UUID = 4,
    VT_PAYLOAD_TYPE = 6,
    VT_PAYLOAD = 8,
    VT_CONTROLLER_ID = 10,
    VT_STATUS = 12,
    VT_NATIVE_STATUS = 14,
    VT_NATIVE_CLASS = 16
  };
  const flatbuffers::String *uuid() const {
    return GetPointer<const flatbuffers::String *>(VT_UUID);
  }
  Payload payload_type() const {
    return static_cast<Payload>(GetField<uint8_t>(VT_PAYLOAD_TYPE, 0));
  }
  const void *payload() const {
    return GetPointer<const void *>(VT_PAYLOAD);
  }
  template<typename T> const T *payload_as() const;
  const CancelConnection *payload_as_CancelConnection() const {
    return payload_type() == Payload::CancelConnection ? static_cast<const CancelConnection *>(payload()) : nullptr;
  }
  const Connect *payload_as_Connect() const {
    return payload_type() == Payload::Connect ? static_cast<const Connect *>(payload()) : nullptr;
  }
  const Disconnect *payload_as_Disconnect() const {
    return payload_type() == Payload::Disconnect ? static_cast<const Disconnect *>(payload()) : nullptr;
  }
  const EmitNotification *payload_as_EmitNotification() const {
    return payload_type() == Payload::EmitNotification ? static_cast<const EmitNotification *>(payload()) : nullptr;
  }
  const GetConnectedDevices *payload_as_GetConnectedDevices() const {
    return payload_type() == Payload::GetConnectedDevices ? static_cast<const GetConnectedDevices *>(payload()) : nullptr;
  }
  const GetControllersIds *payload_as_GetControllersIds() const {
    return payload_type() == Payload::GetControllersIds ? static_cast<const GetControllersIds *>(payload()) : nullptr;
  }
  const GetControllerInfo *payload_as_GetControllerInfo() const {
    return payload_type() == Payload::GetControllerInfo ? static_cast<const GetControllerInfo *>(payload()) : nullptr;
  }
  const GetControllersList *payload_as_GetControllersList() const {
    return payload_type() == Payload::GetControllersList ? static_cast<const GetControllersList *>(payload()) : nullptr;
  }
  const ProbeCharacteristics *payload_as_ProbeCharacteristics() const {
    return payload_type() == Payload::ProbeCharacteristics ? static_cast<const ProbeCharacteristics *>(payload()) : nullptr;
  }
  const ProbeServices *payload_as_ProbeServices() const {
    return payload_type() == Payload::ProbeServices ? static_cast<const ProbeServices *>(payload()) : nullptr;
  }
  const ReadCentral *payload_as_ReadCentral() const {
    return payload_type() == Payload::ReadCentral ? static_cast<const ReadCentral *>(payload()) : nullptr;
  }
  const ReadPeripheral *payload_as_ReadPeripheral() const {
    return payload_type() == Payload::ReadPeripheral ? static_cast<const ReadPeripheral *>(payload()) : nullptr;
  }
  const SetAdvertising *payload_as_SetAdvertising() const {
    return payload_type() == Payload::SetAdvertising ? static_cast<const SetAdvertising *>(payload()) : nullptr;
  }
  const SetConnectable *payload_as_SetConnectable() const {
    return payload_type() == Payload::SetConnectable ? static_cast<const SetConnectable *>(payload()) : nullptr;
  }
  const SetDiscoverable *payload_as_SetDiscoverable() const {
    return payload_type() == Payload::SetDiscoverable ? static_cast<const SetDiscoverable *>(payload()) : nullptr;
  }
  const SetPowered *payload_as_SetPowered() const {
    return payload_type() == Payload::SetPowered ? static_cast<const SetPowered *>(payload()) : nullptr;
  }
  const StartScan *payload_as_StartScan() const {
    return payload_type() == Payload::StartScan ? static_cast<const StartScan *>(payload()) : nullptr;
  }
  const StopScan *payload_as_StopScan() const {
    return payload_type() == Payload::StopScan ? static_cast<const StopScan *>(payload()) : nullptr;
  }
  const WriteCentral *payload_as_WriteCentral() const {
    return payload_type() == Payload::WriteCentral ? static_cast<const WriteCentral *>(payload()) : nullptr;
  }
  const WritePeripheral *payload_as_WritePeripheral() const {
    return payload_type() == Payload::WritePeripheral ? static_cast<const WritePeripheral *>(payload()) : nullptr;
  }
  const WriteWithoutResponseCentral *payload_as_WriteWithoutResponseCentral() const {
    return payload_type() == Payload::WriteWithoutResponseCentral ? static_cast<const WriteWithoutResponseCentral *>(payload()) : nullptr;
  }
  const WriteWithoutResponsePeripheral *payload_as_WriteWithoutResponsePeripheral() const {
    return payload_type() == Payload::WriteWithoutResponsePeripheral ? static_cast<const WriteWithoutResponsePeripheral *>(payload()) : nullptr;
  }
  const ControllerAdded *payload_as_ControllerAdded() const {
    return payload_type() == Payload::ControllerAdded ? static_cast<const ControllerAdded *>(payload()) : nullptr;
  }
  const ControllerRemoved *payload_as_ControllerRemoved() const {
    return payload_type() == Payload::ControllerRemoved ? static_cast<const ControllerRemoved *>(payload()) : nullptr;
  }
  const DeviceConnected *payload_as_DeviceConnected() const {
    return payload_type() == Payload::DeviceConnected ? static_cast<const DeviceConnected *>(payload()) : nullptr;
  }
  const DeviceDisconnected *payload_as_DeviceDisconnected() const {
    return payload_type() == Payload::DeviceDisconnected ? static_cast<const DeviceDisconnected *>(payload()) : nullptr;
  }
  const DeviceFound *payload_as_DeviceFound() const {
    return payload_type() == Payload::DeviceFound ? static_cast<const DeviceFound *>(payload()) : nullptr;
  }
  const NotificationReceived *payload_as_NotificationReceived() const {
    return payload_type() == Payload::NotificationReceived ? static_cast<const NotificationReceived *>(payload()) : nullptr;
  }
  const BaBLEError *payload_as_BaBLEError() const {
    return payload_type() == Payload::BaBLEError ? static_cast<const BaBLEError *>(payload()) : nullptr;
  }
  const Exit *payload_as_Exit() const {
    return payload_type() == Payload::Exit ? static_cast<const Exit *>(payload()) : nullptr;
  }
  const Ready *payload_as_Ready() const {
    return payload_type() == Payload::Ready ? static_cast<const Ready *>(payload()) : nullptr;
  }
  const SetGATTTable *payload_as_SetGATTTable() const {
    return payload_type() == Payload::SetGATTTable ? static_cast<const SetGATTTable *>(payload()) : nullptr;
  }
  uint16_t controller_id() const {
    return GetField<uint16_t>(VT_CONTROLLER_ID, 65535);
  }
  StatusCode status() const {
    return static_cast<StatusCode>(GetField<uint8_t>(VT_STATUS, 0));
  }
  uint8_t native_status() const {
    return GetField<uint8_t>(VT_NATIVE_STATUS, 0);
  }
  const flatbuffers::String *native_class() const {
    return GetPointer<const flatbuffers::String *>(VT_NATIVE_CLASS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_UUID) &&
           verifier.Verify(uuid()) &&
           VerifyField<uint8_t>(verifier, VT_PAYLOAD_TYPE) &&
           VerifyOffset(verifier, VT_PAYLOAD) &&
           VerifyPayload(verifier, payload(), payload_type()) &&
           VerifyField<uint16_t>(verifier, VT_CONTROLLER_ID) &&
           VerifyField<uint8_t>(verifier, VT_STATUS) &&
           VerifyField<uint8_t>(verifier, VT_NATIVE_STATUS) &&
           VerifyOffset(verifier, VT_NATIVE_CLASS) &&
           verifier.Verify(native_class()) &&
           verifier.EndTable();
  }
};

template<> inline const CancelConnection *Packet::payload_as<CancelConnection>() const {
  return payload_as_CancelConnection();
}

template<> inline const Connect *Packet::payload_as<Connect>() const {
  return payload_as_Connect();
}

template<> inline const Disconnect *Packet::payload_as<Disconnect>() const {
  return payload_as_Disconnect();
}

template<> inline const EmitNotification *Packet::payload_as<EmitNotification>() const {
  return payload_as_EmitNotification();
}

template<> inline const GetConnectedDevices *Packet::payload_as<GetConnectedDevices>() const {
  return payload_as_GetConnectedDevices();
}

template<> inline const GetControllersIds *Packet::payload_as<GetControllersIds>() const {
  return payload_as_GetControllersIds();
}

template<> inline const GetControllerInfo *Packet::payload_as<GetControllerInfo>() const {
  return payload_as_GetControllerInfo();
}

template<> inline const GetControllersList *Packet::payload_as<GetControllersList>() const {
  return payload_as_GetControllersList();
}

template<> inline const ProbeCharacteristics *Packet::payload_as<ProbeCharacteristics>() const {
  return payload_as_ProbeCharacteristics();
}

template<> inline const ProbeServices *Packet::payload_as<ProbeServices>() const {
  return payload_as_ProbeServices();
}

template<> inline const ReadCentral *Packet::payload_as<ReadCentral>() const {
  return payload_as_ReadCentral();
}

template<> inline const ReadPeripheral *Packet::payload_as<ReadPeripheral>() const {
  return payload_as_ReadPeripheral();
}

template<> inline const SetAdvertising *Packet::payload_as<SetAdvertising>() const {
  return payload_as_SetAdvertising();
}

template<> inline const SetConnectable *Packet::payload_as<SetConnectable>() const {
  return payload_as_SetConnectable();
}

template<> inline const SetDiscoverable *Packet::payload_as<SetDiscoverable>() const {
  return payload_as_SetDiscoverable();
}

template<> inline const SetPowered *Packet::payload_as<SetPowered>() const {
  return payload_as_SetPowered();
}

template<> inline const StartScan *Packet::payload_as<StartScan>() const {
  return payload_as_StartScan();
}

template<> inline const StopScan *Packet::payload_as<StopScan>() const {
  return payload_as_StopScan();
}

template<> inline const WriteCentral *Packet::payload_as<WriteCentral>() const {
  return payload_as_WriteCentral();
}

template<> inline const WritePeripheral *Packet::payload_as<WritePeripheral>() const {
  return payload_as_WritePeripheral();
}

template<> inline const WriteWithoutResponseCentral *Packet::payload_as<WriteWithoutResponseCentral>() const {
  return payload_as_WriteWithoutResponseCentral();
}

template<> inline const WriteWithoutResponsePeripheral *Packet::payload_as<WriteWithoutResponsePeripheral>() const {
  return payload_as_WriteWithoutResponsePeripheral();
}

template<> inline const ControllerAdded *Packet::payload_as<ControllerAdded>() const {
  return payload_as_ControllerAdded();
}

template<> inline const ControllerRemoved *Packet::payload_as<ControllerRemoved>() const {
  return payload_as_ControllerRemoved();
}

template<> inline const DeviceConnected *Packet::payload_as<DeviceConnected>() const {
  return payload_as_DeviceConnected();
}

template<> inline const DeviceDisconnected *Packet::payload_as<DeviceDisconnected>() const {
  return payload_as_DeviceDisconnected();
}

template<> inline const DeviceFound *Packet::payload_as<DeviceFound>() const {
  return payload_as_DeviceFound();
}

template<> inline const NotificationReceived *Packet::payload_as<NotificationReceived>() const {
  return payload_as_NotificationReceived();
}

template<> inline const BaBLEError *Packet::payload_as<BaBLEError>() const {
  return payload_as_BaBLEError();
}

template<> inline const Exit *Packet::payload_as<Exit>() const {
  return payload_as_Exit();
}

template<> inline const Ready *Packet::payload_as<Ready>() const {
  return payload_as_Ready();
}

template<> inline const SetGATTTable *Packet::payload_as<SetGATTTable>() const {
  return payload_as_SetGATTTable();
}

struct PacketBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_uuid(flatbuffers::Offset<flatbuffers::String> uuid) {
    fbb_.AddOffset(Packet::VT_UUID, uuid);
  }
  void add_payload_type(Payload payload_type) {
    fbb_.AddElement<uint8_t>(Packet::VT_PAYLOAD_TYPE, static_cast<uint8_t>(payload_type), 0);
  }
  void add_payload(flatbuffers::Offset<void> payload) {
    fbb_.AddOffset(Packet::VT_PAYLOAD, payload);
  }
  void add_controller_id(uint16_t controller_id) {
    fbb_.AddElement<uint16_t>(Packet::VT_CONTROLLER_ID, controller_id, 65535);
  }
  void add_status(StatusCode status) {
    fbb_.AddElement<uint8_t>(Packet::VT_STATUS, static_cast<uint8_t>(status), 0);
  }
  void add_native_status(uint8_t native_status) {
    fbb_.AddElement<uint8_t>(Packet::VT_NATIVE_STATUS, native_status, 0);
  }
  void add_native_class(flatbuffers::Offset<flatbuffers::String> native_class) {
    fbb_.AddOffset(Packet::VT_NATIVE_CLASS, native_class);
  }
  explicit PacketBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PacketBuilder &operator=(const PacketBuilder &);
  flatbuffers::Offset<Packet> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Packet>(end);
    return o;
  }
};

inline flatbuffers::Offset<Packet> CreatePacket(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> uuid = 0,
    Payload payload_type = Payload::NONE,
    flatbuffers::Offset<void> payload = 0,
    uint16_t controller_id = 65535,
    StatusCode status = StatusCode::Success,
    uint8_t native_status = 0,
    flatbuffers::Offset<flatbuffers::String> native_class = 0) {
  PacketBuilder builder_(_fbb);
  builder_.add_native_class(native_class);
  builder_.add_payload(payload);
  builder_.add_uuid(uuid);
  builder_.add_controller_id(controller_id);
  builder_.add_native_status(native_status);
  builder_.add_status(status);
  builder_.add_payload_type(payload_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Packet> CreatePacketDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *uuid = nullptr,
    Payload payload_type = Payload::NONE,
    flatbuffers::Offset<void> payload = 0,
    uint16_t controller_id = 65535,
    StatusCode status = StatusCode::Success,
    uint8_t native_status = 0,
    const char *native_class = nullptr) {
  return BaBLE::CreatePacket(
      _fbb,
      uuid ? _fbb.CreateString(uuid) : 0,
      payload_type,
      payload,
      controller_id,
      status,
      native_status,
      native_class ? _fbb.CreateString(native_class) : 0);
}

inline bool VerifyPayload(flatbuffers::Verifier &verifier, const void *obj, Payload type) {
  switch (type) {
    case Payload::NONE: {
      return true;
    }
    case Payload::CancelConnection: {
      auto ptr = reinterpret_cast<const CancelConnection *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::Connect: {
      auto ptr = reinterpret_cast<const Connect *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::Disconnect: {
      auto ptr = reinterpret_cast<const Disconnect *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::EmitNotification: {
      auto ptr = reinterpret_cast<const EmitNotification *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::GetConnectedDevices: {
      auto ptr = reinterpret_cast<const GetConnectedDevices *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::GetControllersIds: {
      auto ptr = reinterpret_cast<const GetControllersIds *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::GetControllerInfo: {
      auto ptr = reinterpret_cast<const GetControllerInfo *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::GetControllersList: {
      auto ptr = reinterpret_cast<const GetControllersList *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::ProbeCharacteristics: {
      auto ptr = reinterpret_cast<const ProbeCharacteristics *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::ProbeServices: {
      auto ptr = reinterpret_cast<const ProbeServices *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::ReadCentral: {
      auto ptr = reinterpret_cast<const ReadCentral *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::ReadPeripheral: {
      auto ptr = reinterpret_cast<const ReadPeripheral *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::SetAdvertising: {
      auto ptr = reinterpret_cast<const SetAdvertising *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::SetConnectable: {
      auto ptr = reinterpret_cast<const SetConnectable *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::SetDiscoverable: {
      auto ptr = reinterpret_cast<const SetDiscoverable *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::SetPowered: {
      auto ptr = reinterpret_cast<const SetPowered *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::StartScan: {
      auto ptr = reinterpret_cast<const StartScan *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::StopScan: {
      auto ptr = reinterpret_cast<const StopScan *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::WriteCentral: {
      auto ptr = reinterpret_cast<const WriteCentral *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::WritePeripheral: {
      auto ptr = reinterpret_cast<const WritePeripheral *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::WriteWithoutResponseCentral: {
      auto ptr = reinterpret_cast<const WriteWithoutResponseCentral *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::WriteWithoutResponsePeripheral: {
      auto ptr = reinterpret_cast<const WriteWithoutResponsePeripheral *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::ControllerAdded: {
      auto ptr = reinterpret_cast<const ControllerAdded *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::ControllerRemoved: {
      auto ptr = reinterpret_cast<const ControllerRemoved *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::DeviceConnected: {
      auto ptr = reinterpret_cast<const DeviceConnected *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::DeviceDisconnected: {
      auto ptr = reinterpret_cast<const DeviceDisconnected *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::DeviceFound: {
      auto ptr = reinterpret_cast<const DeviceFound *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::NotificationReceived: {
      auto ptr = reinterpret_cast<const NotificationReceived *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::BaBLEError: {
      auto ptr = reinterpret_cast<const BaBLEError *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::Exit: {
      auto ptr = reinterpret_cast<const Exit *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::Ready: {
      auto ptr = reinterpret_cast<const Ready *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::SetGATTTable: {
      auto ptr = reinterpret_cast<const SetGATTTable *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyPayloadVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyPayload(
        verifier,  values->Get(i), types->GetEnum<Payload>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyModel(flatbuffers::Verifier &verifier, const void *obj, Model type) {
  switch (type) {
    case Model::NONE: {
      return true;
    }
    case Model::Characteristic: {
      auto ptr = reinterpret_cast<const Characteristic *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Model::Controller: {
      auto ptr = reinterpret_cast<const Controller *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Model::Device: {
      auto ptr = reinterpret_cast<const Device *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Model::Service: {
      auto ptr = reinterpret_cast<const Service *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyModelVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyModel(
        verifier,  values->Get(i), types->GetEnum<Model>(i))) {
      return false;
    }
  }
  return true;
}

inline const BaBLE::Packet *GetPacket(const void *buf) {
  return flatbuffers::GetRoot<BaBLE::Packet>(buf);
}

inline const BaBLE::Packet *GetSizePrefixedPacket(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<BaBLE::Packet>(buf);
}

inline bool VerifyPacketBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<BaBLE::Packet>(nullptr);
}

inline bool VerifySizePrefixedPacketBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<BaBLE::Packet>(nullptr);
}

inline void FinishPacketBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<BaBLE::Packet> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedPacketBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<BaBLE::Packet> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace BaBLE

#endif  // FLATBUFFERS_GENERATED_PACKET_BABLE_H_
