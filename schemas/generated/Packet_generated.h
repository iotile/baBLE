// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_PACKET_SCHEMAS_H_
#define FLATBUFFERS_GENERATED_PACKET_SCHEMAS_H_

#include "flatbuffers/flatbuffers.h"

namespace Schemas {

struct GetMGMTInfo;

struct StartScan;

struct StopScan;

struct AddDevice;

struct RemoveDevice;

struct Disconnect;

struct SetPowered;

struct DeviceConnected;

struct DeviceDisconnected;

struct DeviceFound;

struct Discovering;

struct BaBLEError;

struct Packet;

enum class Payload : uint8_t {
  NONE = 0,
  AddDevice = 1,
  Disconnect = 2,
  GetMGMTInfo = 3,
  RemoveDevice = 4,
  SetPowered = 5,
  StartScan = 6,
  StopScan = 7,
  DeviceConnected = 8,
  DeviceDisconnected = 9,
  DeviceFound = 10,
  Discovering = 11,
  BaBLEError = 12,
  MIN = NONE,
  MAX = BaBLEError
};

inline const Payload (&EnumValuesPayload())[13] {
  static const Payload values[] = {
    Payload::NONE,
    Payload::AddDevice,
    Payload::Disconnect,
    Payload::GetMGMTInfo,
    Payload::RemoveDevice,
    Payload::SetPowered,
    Payload::StartScan,
    Payload::StopScan,
    Payload::DeviceConnected,
    Payload::DeviceDisconnected,
    Payload::DeviceFound,
    Payload::Discovering,
    Payload::BaBLEError
  };
  return values;
}

inline const char * const *EnumNamesPayload() {
  static const char * const names[] = {
    "NONE",
    "AddDevice",
    "Disconnect",
    "GetMGMTInfo",
    "RemoveDevice",
    "SetPowered",
    "StartScan",
    "StopScan",
    "DeviceConnected",
    "DeviceDisconnected",
    "DeviceFound",
    "Discovering",
    "BaBLEError",
    nullptr
  };
  return names;
}

inline const char *EnumNamePayload(Payload e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesPayload()[index];
}

template<typename T> struct PayloadTraits {
  static const Payload enum_value = Payload::NONE;
};

template<> struct PayloadTraits<AddDevice> {
  static const Payload enum_value = Payload::AddDevice;
};

template<> struct PayloadTraits<Disconnect> {
  static const Payload enum_value = Payload::Disconnect;
};

template<> struct PayloadTraits<GetMGMTInfo> {
  static const Payload enum_value = Payload::GetMGMTInfo;
};

template<> struct PayloadTraits<RemoveDevice> {
  static const Payload enum_value = Payload::RemoveDevice;
};

template<> struct PayloadTraits<SetPowered> {
  static const Payload enum_value = Payload::SetPowered;
};

template<> struct PayloadTraits<StartScan> {
  static const Payload enum_value = Payload::StartScan;
};

template<> struct PayloadTraits<StopScan> {
  static const Payload enum_value = Payload::StopScan;
};

template<> struct PayloadTraits<DeviceConnected> {
  static const Payload enum_value = Payload::DeviceConnected;
};

template<> struct PayloadTraits<DeviceDisconnected> {
  static const Payload enum_value = Payload::DeviceDisconnected;
};

template<> struct PayloadTraits<DeviceFound> {
  static const Payload enum_value = Payload::DeviceFound;
};

template<> struct PayloadTraits<Discovering> {
  static const Payload enum_value = Payload::Discovering;
};

template<> struct PayloadTraits<BaBLEError> {
  static const Payload enum_value = Payload::BaBLEError;
};

bool VerifyPayload(flatbuffers::Verifier &verifier, const void *obj, Payload type);
bool VerifyPayloadVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class StatusCode : uint8_t {
  Success = 0,
  SocketError = 1,
  NotFound = 2,
  WrongFormat = 3,
  InvalidCommand = 4,
  Unknown = 5,
  Rejected = 6,
  Denied = 7,
  Cancelled = 8,
  NotPowered = 9,
  Failed = 10,
  NotConnected = 11,
  MIN = Success,
  MAX = NotConnected
};

inline const StatusCode (&EnumValuesStatusCode())[12] {
  static const StatusCode values[] = {
    StatusCode::Success,
    StatusCode::SocketError,
    StatusCode::NotFound,
    StatusCode::WrongFormat,
    StatusCode::InvalidCommand,
    StatusCode::Unknown,
    StatusCode::Rejected,
    StatusCode::Denied,
    StatusCode::Cancelled,
    StatusCode::NotPowered,
    StatusCode::Failed,
    StatusCode::NotConnected
  };
  return values;
}

inline const char * const *EnumNamesStatusCode() {
  static const char * const names[] = {
    "Success",
    "SocketError",
    "NotFound",
    "WrongFormat",
    "InvalidCommand",
    "Unknown",
    "Rejected",
    "Denied",
    "Cancelled",
    "NotPowered",
    "Failed",
    "NotConnected",
    nullptr
  };
  return names;
}

inline const char *EnumNameStatusCode(StatusCode e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesStatusCode()[index];
}

struct GetMGMTInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VERSION = 4,
    VT_REVISION = 6
  };
  uint8_t version() const {
    return GetField<uint8_t>(VT_VERSION, 0);
  }
  uint16_t revision() const {
    return GetField<uint16_t>(VT_REVISION, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VERSION) &&
           VerifyField<uint16_t>(verifier, VT_REVISION) &&
           verifier.EndTable();
  }
};

struct GetMGMTInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_version(uint8_t version) {
    fbb_.AddElement<uint8_t>(GetMGMTInfo::VT_VERSION, version, 0);
  }
  void add_revision(uint16_t revision) {
    fbb_.AddElement<uint16_t>(GetMGMTInfo::VT_REVISION, revision, 0);
  }
  explicit GetMGMTInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GetMGMTInfoBuilder &operator=(const GetMGMTInfoBuilder &);
  flatbuffers::Offset<GetMGMTInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GetMGMTInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<GetMGMTInfo> CreateGetMGMTInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t version = 0,
    uint16_t revision = 0) {
  GetMGMTInfoBuilder builder_(_fbb);
  builder_.add_revision(revision);
  builder_.add_version(version);
  return builder_.Finish();
}

struct StartScan FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CONTROLLER_ID = 4,
    VT_ADDRESS_TYPE = 6
  };
  uint16_t controller_id() const {
    return GetField<uint16_t>(VT_CONTROLLER_ID, 0);
  }
  uint8_t address_type() const {
    return GetField<uint8_t>(VT_ADDRESS_TYPE, 6);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_CONTROLLER_ID) &&
           VerifyField<uint8_t>(verifier, VT_ADDRESS_TYPE) &&
           verifier.EndTable();
  }
};

struct StartScanBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_controller_id(uint16_t controller_id) {
    fbb_.AddElement<uint16_t>(StartScan::VT_CONTROLLER_ID, controller_id, 0);
  }
  void add_address_type(uint8_t address_type) {
    fbb_.AddElement<uint8_t>(StartScan::VT_ADDRESS_TYPE, address_type, 6);
  }
  explicit StartScanBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StartScanBuilder &operator=(const StartScanBuilder &);
  flatbuffers::Offset<StartScan> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StartScan>(end);
    return o;
  }
};

inline flatbuffers::Offset<StartScan> CreateStartScan(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t controller_id = 0,
    uint8_t address_type = 6) {
  StartScanBuilder builder_(_fbb);
  builder_.add_controller_id(controller_id);
  builder_.add_address_type(address_type);
  return builder_.Finish();
}

struct StopScan FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CONTROLLER_ID = 4,
    VT_ADDRESS_TYPE = 6
  };
  uint16_t controller_id() const {
    return GetField<uint16_t>(VT_CONTROLLER_ID, 0);
  }
  uint8_t address_type() const {
    return GetField<uint8_t>(VT_ADDRESS_TYPE, 6);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_CONTROLLER_ID) &&
           VerifyField<uint8_t>(verifier, VT_ADDRESS_TYPE) &&
           verifier.EndTable();
  }
};

struct StopScanBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_controller_id(uint16_t controller_id) {
    fbb_.AddElement<uint16_t>(StopScan::VT_CONTROLLER_ID, controller_id, 0);
  }
  void add_address_type(uint8_t address_type) {
    fbb_.AddElement<uint8_t>(StopScan::VT_ADDRESS_TYPE, address_type, 6);
  }
  explicit StopScanBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StopScanBuilder &operator=(const StopScanBuilder &);
  flatbuffers::Offset<StopScan> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StopScan>(end);
    return o;
  }
};

inline flatbuffers::Offset<StopScan> CreateStopScan(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t controller_id = 0,
    uint8_t address_type = 6) {
  StopScanBuilder builder_(_fbb);
  builder_.add_controller_id(controller_id);
  builder_.add_address_type(address_type);
  return builder_.Finish();
}

struct AddDevice FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CONTROLLER_ID = 4,
    VT_ADDRESS = 6,
    VT_ADDRESS_TYPE = 8
  };
  uint16_t controller_id() const {
    return GetField<uint16_t>(VT_CONTROLLER_ID, 0);
  }
  const flatbuffers::Vector<uint8_t> *address() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_ADDRESS);
  }
  uint8_t address_type() const {
    return GetField<uint8_t>(VT_ADDRESS_TYPE, 2);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_CONTROLLER_ID) &&
           VerifyOffset(verifier, VT_ADDRESS) &&
           verifier.Verify(address()) &&
           VerifyField<uint8_t>(verifier, VT_ADDRESS_TYPE) &&
           verifier.EndTable();
  }
};

struct AddDeviceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_controller_id(uint16_t controller_id) {
    fbb_.AddElement<uint16_t>(AddDevice::VT_CONTROLLER_ID, controller_id, 0);
  }
  void add_address(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> address) {
    fbb_.AddOffset(AddDevice::VT_ADDRESS, address);
  }
  void add_address_type(uint8_t address_type) {
    fbb_.AddElement<uint8_t>(AddDevice::VT_ADDRESS_TYPE, address_type, 2);
  }
  explicit AddDeviceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AddDeviceBuilder &operator=(const AddDeviceBuilder &);
  flatbuffers::Offset<AddDevice> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AddDevice>(end);
    return o;
  }
};

inline flatbuffers::Offset<AddDevice> CreateAddDevice(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t controller_id = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> address = 0,
    uint8_t address_type = 2) {
  AddDeviceBuilder builder_(_fbb);
  builder_.add_address(address);
  builder_.add_controller_id(controller_id);
  builder_.add_address_type(address_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<AddDevice> CreateAddDeviceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t controller_id = 0,
    const std::vector<uint8_t> *address = nullptr,
    uint8_t address_type = 2) {
  return Schemas::CreateAddDevice(
      _fbb,
      controller_id,
      address ? _fbb.CreateVector<uint8_t>(*address) : 0,
      address_type);
}

struct RemoveDevice FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CONTROLLER_ID = 4,
    VT_ADDRESS = 6,
    VT_ADDRESS_TYPE = 8
  };
  uint16_t controller_id() const {
    return GetField<uint16_t>(VT_CONTROLLER_ID, 0);
  }
  const flatbuffers::Vector<uint8_t> *address() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_ADDRESS);
  }
  uint8_t address_type() const {
    return GetField<uint8_t>(VT_ADDRESS_TYPE, 2);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_CONTROLLER_ID) &&
           VerifyOffset(verifier, VT_ADDRESS) &&
           verifier.Verify(address()) &&
           VerifyField<uint8_t>(verifier, VT_ADDRESS_TYPE) &&
           verifier.EndTable();
  }
};

struct RemoveDeviceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_controller_id(uint16_t controller_id) {
    fbb_.AddElement<uint16_t>(RemoveDevice::VT_CONTROLLER_ID, controller_id, 0);
  }
  void add_address(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> address) {
    fbb_.AddOffset(RemoveDevice::VT_ADDRESS, address);
  }
  void add_address_type(uint8_t address_type) {
    fbb_.AddElement<uint8_t>(RemoveDevice::VT_ADDRESS_TYPE, address_type, 2);
  }
  explicit RemoveDeviceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RemoveDeviceBuilder &operator=(const RemoveDeviceBuilder &);
  flatbuffers::Offset<RemoveDevice> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RemoveDevice>(end);
    return o;
  }
};

inline flatbuffers::Offset<RemoveDevice> CreateRemoveDevice(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t controller_id = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> address = 0,
    uint8_t address_type = 2) {
  RemoveDeviceBuilder builder_(_fbb);
  builder_.add_address(address);
  builder_.add_controller_id(controller_id);
  builder_.add_address_type(address_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<RemoveDevice> CreateRemoveDeviceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t controller_id = 0,
    const std::vector<uint8_t> *address = nullptr,
    uint8_t address_type = 2) {
  return Schemas::CreateRemoveDevice(
      _fbb,
      controller_id,
      address ? _fbb.CreateVector<uint8_t>(*address) : 0,
      address_type);
}

struct Disconnect FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CONTROLLER_ID = 4,
    VT_ADDRESS = 6,
    VT_ADDRESS_TYPE = 8
  };
  uint16_t controller_id() const {
    return GetField<uint16_t>(VT_CONTROLLER_ID, 0);
  }
  const flatbuffers::Vector<uint8_t> *address() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_ADDRESS);
  }
  uint8_t address_type() const {
    return GetField<uint8_t>(VT_ADDRESS_TYPE, 2);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_CONTROLLER_ID) &&
           VerifyOffset(verifier, VT_ADDRESS) &&
           verifier.Verify(address()) &&
           VerifyField<uint8_t>(verifier, VT_ADDRESS_TYPE) &&
           verifier.EndTable();
  }
};

struct DisconnectBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_controller_id(uint16_t controller_id) {
    fbb_.AddElement<uint16_t>(Disconnect::VT_CONTROLLER_ID, controller_id, 0);
  }
  void add_address(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> address) {
    fbb_.AddOffset(Disconnect::VT_ADDRESS, address);
  }
  void add_address_type(uint8_t address_type) {
    fbb_.AddElement<uint8_t>(Disconnect::VT_ADDRESS_TYPE, address_type, 2);
  }
  explicit DisconnectBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DisconnectBuilder &operator=(const DisconnectBuilder &);
  flatbuffers::Offset<Disconnect> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Disconnect>(end);
    return o;
  }
};

inline flatbuffers::Offset<Disconnect> CreateDisconnect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t controller_id = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> address = 0,
    uint8_t address_type = 2) {
  DisconnectBuilder builder_(_fbb);
  builder_.add_address(address);
  builder_.add_controller_id(controller_id);
  builder_.add_address_type(address_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Disconnect> CreateDisconnectDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t controller_id = 0,
    const std::vector<uint8_t> *address = nullptr,
    uint8_t address_type = 2) {
  return Schemas::CreateDisconnect(
      _fbb,
      controller_id,
      address ? _fbb.CreateVector<uint8_t>(*address) : 0,
      address_type);
}

struct SetPowered FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CONTROLLER_ID = 4,
    VT_STATE = 6
  };
  uint16_t controller_id() const {
    return GetField<uint16_t>(VT_CONTROLLER_ID, 0);
  }
  bool state() const {
    return GetField<uint8_t>(VT_STATE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_CONTROLLER_ID) &&
           VerifyField<uint8_t>(verifier, VT_STATE) &&
           verifier.EndTable();
  }
};

struct SetPoweredBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_controller_id(uint16_t controller_id) {
    fbb_.AddElement<uint16_t>(SetPowered::VT_CONTROLLER_ID, controller_id, 0);
  }
  void add_state(bool state) {
    fbb_.AddElement<uint8_t>(SetPowered::VT_STATE, static_cast<uint8_t>(state), 0);
  }
  explicit SetPoweredBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SetPoweredBuilder &operator=(const SetPoweredBuilder &);
  flatbuffers::Offset<SetPowered> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SetPowered>(end);
    return o;
  }
};

inline flatbuffers::Offset<SetPowered> CreateSetPowered(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t controller_id = 0,
    bool state = false) {
  SetPoweredBuilder builder_(_fbb);
  builder_.add_controller_id(controller_id);
  builder_.add_state(state);
  return builder_.Finish();
}

struct DeviceConnected FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CONTROLLER_ID = 4,
    VT_ADDRESS = 6,
    VT_ADDRESS_TYPE = 8,
    VT_FLAGS = 10,
    VT_UUID = 12,
    VT_COMPANY_ID = 14,
    VT_DEVICE_NAME = 16
  };
  uint16_t controller_id() const {
    return GetField<uint16_t>(VT_CONTROLLER_ID, 0);
  }
  const flatbuffers::String *address() const {
    return GetPointer<const flatbuffers::String *>(VT_ADDRESS);
  }
  uint8_t address_type() const {
    return GetField<uint8_t>(VT_ADDRESS_TYPE, 0);
  }
  const flatbuffers::Vector<uint8_t> *flags() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_FLAGS);
  }
  const flatbuffers::String *uuid() const {
    return GetPointer<const flatbuffers::String *>(VT_UUID);
  }
  uint16_t company_id() const {
    return GetField<uint16_t>(VT_COMPANY_ID, 0);
  }
  const flatbuffers::String *device_name() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICE_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_CONTROLLER_ID) &&
           VerifyOffset(verifier, VT_ADDRESS) &&
           verifier.Verify(address()) &&
           VerifyField<uint8_t>(verifier, VT_ADDRESS_TYPE) &&
           VerifyOffset(verifier, VT_FLAGS) &&
           verifier.Verify(flags()) &&
           VerifyOffset(verifier, VT_UUID) &&
           verifier.Verify(uuid()) &&
           VerifyField<uint16_t>(verifier, VT_COMPANY_ID) &&
           VerifyOffset(verifier, VT_DEVICE_NAME) &&
           verifier.Verify(device_name()) &&
           verifier.EndTable();
  }
};

struct DeviceConnectedBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_controller_id(uint16_t controller_id) {
    fbb_.AddElement<uint16_t>(DeviceConnected::VT_CONTROLLER_ID, controller_id, 0);
  }
  void add_address(flatbuffers::Offset<flatbuffers::String> address) {
    fbb_.AddOffset(DeviceConnected::VT_ADDRESS, address);
  }
  void add_address_type(uint8_t address_type) {
    fbb_.AddElement<uint8_t>(DeviceConnected::VT_ADDRESS_TYPE, address_type, 0);
  }
  void add_flags(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> flags) {
    fbb_.AddOffset(DeviceConnected::VT_FLAGS, flags);
  }
  void add_uuid(flatbuffers::Offset<flatbuffers::String> uuid) {
    fbb_.AddOffset(DeviceConnected::VT_UUID, uuid);
  }
  void add_company_id(uint16_t company_id) {
    fbb_.AddElement<uint16_t>(DeviceConnected::VT_COMPANY_ID, company_id, 0);
  }
  void add_device_name(flatbuffers::Offset<flatbuffers::String> device_name) {
    fbb_.AddOffset(DeviceConnected::VT_DEVICE_NAME, device_name);
  }
  explicit DeviceConnectedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DeviceConnectedBuilder &operator=(const DeviceConnectedBuilder &);
  flatbuffers::Offset<DeviceConnected> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DeviceConnected>(end);
    return o;
  }
};

inline flatbuffers::Offset<DeviceConnected> CreateDeviceConnected(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t controller_id = 0,
    flatbuffers::Offset<flatbuffers::String> address = 0,
    uint8_t address_type = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> flags = 0,
    flatbuffers::Offset<flatbuffers::String> uuid = 0,
    uint16_t company_id = 0,
    flatbuffers::Offset<flatbuffers::String> device_name = 0) {
  DeviceConnectedBuilder builder_(_fbb);
  builder_.add_device_name(device_name);
  builder_.add_uuid(uuid);
  builder_.add_flags(flags);
  builder_.add_address(address);
  builder_.add_company_id(company_id);
  builder_.add_controller_id(controller_id);
  builder_.add_address_type(address_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<DeviceConnected> CreateDeviceConnectedDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t controller_id = 0,
    const char *address = nullptr,
    uint8_t address_type = 0,
    const std::vector<uint8_t> *flags = nullptr,
    const char *uuid = nullptr,
    uint16_t company_id = 0,
    const char *device_name = nullptr) {
  return Schemas::CreateDeviceConnected(
      _fbb,
      controller_id,
      address ? _fbb.CreateString(address) : 0,
      address_type,
      flags ? _fbb.CreateVector<uint8_t>(*flags) : 0,
      uuid ? _fbb.CreateString(uuid) : 0,
      company_id,
      device_name ? _fbb.CreateString(device_name) : 0);
}

struct DeviceDisconnected FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CONTROLLER_ID = 4,
    VT_ADDRESS = 6,
    VT_ADDRESS_TYPE = 8,
    VT_REASON = 10
  };
  uint16_t controller_id() const {
    return GetField<uint16_t>(VT_CONTROLLER_ID, 0);
  }
  const flatbuffers::String *address() const {
    return GetPointer<const flatbuffers::String *>(VT_ADDRESS);
  }
  uint8_t address_type() const {
    return GetField<uint8_t>(VT_ADDRESS_TYPE, 0);
  }
  const flatbuffers::String *reason() const {
    return GetPointer<const flatbuffers::String *>(VT_REASON);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_CONTROLLER_ID) &&
           VerifyOffset(verifier, VT_ADDRESS) &&
           verifier.Verify(address()) &&
           VerifyField<uint8_t>(verifier, VT_ADDRESS_TYPE) &&
           VerifyOffset(verifier, VT_REASON) &&
           verifier.Verify(reason()) &&
           verifier.EndTable();
  }
};

struct DeviceDisconnectedBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_controller_id(uint16_t controller_id) {
    fbb_.AddElement<uint16_t>(DeviceDisconnected::VT_CONTROLLER_ID, controller_id, 0);
  }
  void add_address(flatbuffers::Offset<flatbuffers::String> address) {
    fbb_.AddOffset(DeviceDisconnected::VT_ADDRESS, address);
  }
  void add_address_type(uint8_t address_type) {
    fbb_.AddElement<uint8_t>(DeviceDisconnected::VT_ADDRESS_TYPE, address_type, 0);
  }
  void add_reason(flatbuffers::Offset<flatbuffers::String> reason) {
    fbb_.AddOffset(DeviceDisconnected::VT_REASON, reason);
  }
  explicit DeviceDisconnectedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DeviceDisconnectedBuilder &operator=(const DeviceDisconnectedBuilder &);
  flatbuffers::Offset<DeviceDisconnected> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DeviceDisconnected>(end);
    return o;
  }
};

inline flatbuffers::Offset<DeviceDisconnected> CreateDeviceDisconnected(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t controller_id = 0,
    flatbuffers::Offset<flatbuffers::String> address = 0,
    uint8_t address_type = 0,
    flatbuffers::Offset<flatbuffers::String> reason = 0) {
  DeviceDisconnectedBuilder builder_(_fbb);
  builder_.add_reason(reason);
  builder_.add_address(address);
  builder_.add_controller_id(controller_id);
  builder_.add_address_type(address_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<DeviceDisconnected> CreateDeviceDisconnectedDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t controller_id = 0,
    const char *address = nullptr,
    uint8_t address_type = 0,
    const char *reason = nullptr) {
  return Schemas::CreateDeviceDisconnected(
      _fbb,
      controller_id,
      address ? _fbb.CreateString(address) : 0,
      address_type,
      reason ? _fbb.CreateString(reason) : 0);
}

struct DeviceFound FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CONTROLLER_ID = 4,
    VT_ADDRESS = 6,
    VT_ADDRESS_TYPE = 8,
    VT_RSSI = 10,
    VT_FLAGS = 12,
    VT_UUID = 14,
    VT_COMPANY_ID = 16,
    VT_DEVICE_NAME = 18
  };
  uint16_t controller_id() const {
    return GetField<uint16_t>(VT_CONTROLLER_ID, 0);
  }
  const flatbuffers::String *address() const {
    return GetPointer<const flatbuffers::String *>(VT_ADDRESS);
  }
  uint8_t address_type() const {
    return GetField<uint8_t>(VT_ADDRESS_TYPE, 0);
  }
  int8_t rssi() const {
    return GetField<int8_t>(VT_RSSI, 0);
  }
  const flatbuffers::Vector<uint8_t> *flags() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_FLAGS);
  }
  const flatbuffers::String *uuid() const {
    return GetPointer<const flatbuffers::String *>(VT_UUID);
  }
  uint16_t company_id() const {
    return GetField<uint16_t>(VT_COMPANY_ID, 0);
  }
  const flatbuffers::String *device_name() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICE_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_CONTROLLER_ID) &&
           VerifyOffset(verifier, VT_ADDRESS) &&
           verifier.Verify(address()) &&
           VerifyField<uint8_t>(verifier, VT_ADDRESS_TYPE) &&
           VerifyField<int8_t>(verifier, VT_RSSI) &&
           VerifyOffset(verifier, VT_FLAGS) &&
           verifier.Verify(flags()) &&
           VerifyOffset(verifier, VT_UUID) &&
           verifier.Verify(uuid()) &&
           VerifyField<uint16_t>(verifier, VT_COMPANY_ID) &&
           VerifyOffset(verifier, VT_DEVICE_NAME) &&
           verifier.Verify(device_name()) &&
           verifier.EndTable();
  }
};

struct DeviceFoundBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_controller_id(uint16_t controller_id) {
    fbb_.AddElement<uint16_t>(DeviceFound::VT_CONTROLLER_ID, controller_id, 0);
  }
  void add_address(flatbuffers::Offset<flatbuffers::String> address) {
    fbb_.AddOffset(DeviceFound::VT_ADDRESS, address);
  }
  void add_address_type(uint8_t address_type) {
    fbb_.AddElement<uint8_t>(DeviceFound::VT_ADDRESS_TYPE, address_type, 0);
  }
  void add_rssi(int8_t rssi) {
    fbb_.AddElement<int8_t>(DeviceFound::VT_RSSI, rssi, 0);
  }
  void add_flags(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> flags) {
    fbb_.AddOffset(DeviceFound::VT_FLAGS, flags);
  }
  void add_uuid(flatbuffers::Offset<flatbuffers::String> uuid) {
    fbb_.AddOffset(DeviceFound::VT_UUID, uuid);
  }
  void add_company_id(uint16_t company_id) {
    fbb_.AddElement<uint16_t>(DeviceFound::VT_COMPANY_ID, company_id, 0);
  }
  void add_device_name(flatbuffers::Offset<flatbuffers::String> device_name) {
    fbb_.AddOffset(DeviceFound::VT_DEVICE_NAME, device_name);
  }
  explicit DeviceFoundBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DeviceFoundBuilder &operator=(const DeviceFoundBuilder &);
  flatbuffers::Offset<DeviceFound> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DeviceFound>(end);
    return o;
  }
};

inline flatbuffers::Offset<DeviceFound> CreateDeviceFound(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t controller_id = 0,
    flatbuffers::Offset<flatbuffers::String> address = 0,
    uint8_t address_type = 0,
    int8_t rssi = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> flags = 0,
    flatbuffers::Offset<flatbuffers::String> uuid = 0,
    uint16_t company_id = 0,
    flatbuffers::Offset<flatbuffers::String> device_name = 0) {
  DeviceFoundBuilder builder_(_fbb);
  builder_.add_device_name(device_name);
  builder_.add_uuid(uuid);
  builder_.add_flags(flags);
  builder_.add_address(address);
  builder_.add_company_id(company_id);
  builder_.add_controller_id(controller_id);
  builder_.add_rssi(rssi);
  builder_.add_address_type(address_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<DeviceFound> CreateDeviceFoundDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t controller_id = 0,
    const char *address = nullptr,
    uint8_t address_type = 0,
    int8_t rssi = 0,
    const std::vector<uint8_t> *flags = nullptr,
    const char *uuid = nullptr,
    uint16_t company_id = 0,
    const char *device_name = nullptr) {
  return Schemas::CreateDeviceFound(
      _fbb,
      controller_id,
      address ? _fbb.CreateString(address) : 0,
      address_type,
      rssi,
      flags ? _fbb.CreateVector<uint8_t>(*flags) : 0,
      uuid ? _fbb.CreateString(uuid) : 0,
      company_id,
      device_name ? _fbb.CreateString(device_name) : 0);
}

struct Discovering FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CONTROLLER_ID = 4,
    VT_ADDRESS_TYPE = 6,
    VT_STATE = 8
  };
  uint16_t controller_id() const {
    return GetField<uint16_t>(VT_CONTROLLER_ID, 0);
  }
  uint8_t address_type() const {
    return GetField<uint8_t>(VT_ADDRESS_TYPE, 0);
  }
  bool state() const {
    return GetField<uint8_t>(VT_STATE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_CONTROLLER_ID) &&
           VerifyField<uint8_t>(verifier, VT_ADDRESS_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_STATE) &&
           verifier.EndTable();
  }
};

struct DiscoveringBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_controller_id(uint16_t controller_id) {
    fbb_.AddElement<uint16_t>(Discovering::VT_CONTROLLER_ID, controller_id, 0);
  }
  void add_address_type(uint8_t address_type) {
    fbb_.AddElement<uint8_t>(Discovering::VT_ADDRESS_TYPE, address_type, 0);
  }
  void add_state(bool state) {
    fbb_.AddElement<uint8_t>(Discovering::VT_STATE, static_cast<uint8_t>(state), 0);
  }
  explicit DiscoveringBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DiscoveringBuilder &operator=(const DiscoveringBuilder &);
  flatbuffers::Offset<Discovering> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Discovering>(end);
    return o;
  }
};

inline flatbuffers::Offset<Discovering> CreateDiscovering(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t controller_id = 0,
    uint8_t address_type = 0,
    bool state = false) {
  DiscoveringBuilder builder_(_fbb);
  builder_.add_controller_id(controller_id);
  builder_.add_state(state);
  builder_.add_address_type(address_type);
  return builder_.Finish();
}

struct BaBLEError FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MESSAGE = 4
  };
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.Verify(message()) &&
           verifier.EndTable();
  }
};

struct BaBLEErrorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(BaBLEError::VT_MESSAGE, message);
  }
  explicit BaBLEErrorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BaBLEErrorBuilder &operator=(const BaBLEErrorBuilder &);
  flatbuffers::Offset<BaBLEError> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BaBLEError>(end);
    return o;
  }
};

inline flatbuffers::Offset<BaBLEError> CreateBaBLEError(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> message = 0) {
  BaBLEErrorBuilder builder_(_fbb);
  builder_.add_message(message);
  return builder_.Finish();
}

inline flatbuffers::Offset<BaBLEError> CreateBaBLEErrorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *message = nullptr) {
  return Schemas::CreateBaBLEError(
      _fbb,
      message ? _fbb.CreateString(message) : 0);
}

struct Packet FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PAYLOAD_TYPE = 4,
    VT_PAYLOAD = 6,
    VT_STATUS = 8,
    VT_NATIVE_STATUS = 10,
    VT_NATIVE_CLASS = 12
  };
  Payload payload_type() const {
    return static_cast<Payload>(GetField<uint8_t>(VT_PAYLOAD_TYPE, 0));
  }
  const void *payload() const {
    return GetPointer<const void *>(VT_PAYLOAD);
  }
  template<typename T> const T *payload_as() const;
  const AddDevice *payload_as_AddDevice() const {
    return payload_type() == Payload::AddDevice ? static_cast<const AddDevice *>(payload()) : nullptr;
  }
  const Disconnect *payload_as_Disconnect() const {
    return payload_type() == Payload::Disconnect ? static_cast<const Disconnect *>(payload()) : nullptr;
  }
  const GetMGMTInfo *payload_as_GetMGMTInfo() const {
    return payload_type() == Payload::GetMGMTInfo ? static_cast<const GetMGMTInfo *>(payload()) : nullptr;
  }
  const RemoveDevice *payload_as_RemoveDevice() const {
    return payload_type() == Payload::RemoveDevice ? static_cast<const RemoveDevice *>(payload()) : nullptr;
  }
  const SetPowered *payload_as_SetPowered() const {
    return payload_type() == Payload::SetPowered ? static_cast<const SetPowered *>(payload()) : nullptr;
  }
  const StartScan *payload_as_StartScan() const {
    return payload_type() == Payload::StartScan ? static_cast<const StartScan *>(payload()) : nullptr;
  }
  const StopScan *payload_as_StopScan() const {
    return payload_type() == Payload::StopScan ? static_cast<const StopScan *>(payload()) : nullptr;
  }
  const DeviceConnected *payload_as_DeviceConnected() const {
    return payload_type() == Payload::DeviceConnected ? static_cast<const DeviceConnected *>(payload()) : nullptr;
  }
  const DeviceDisconnected *payload_as_DeviceDisconnected() const {
    return payload_type() == Payload::DeviceDisconnected ? static_cast<const DeviceDisconnected *>(payload()) : nullptr;
  }
  const DeviceFound *payload_as_DeviceFound() const {
    return payload_type() == Payload::DeviceFound ? static_cast<const DeviceFound *>(payload()) : nullptr;
  }
  const Discovering *payload_as_Discovering() const {
    return payload_type() == Payload::Discovering ? static_cast<const Discovering *>(payload()) : nullptr;
  }
  const BaBLEError *payload_as_BaBLEError() const {
    return payload_type() == Payload::BaBLEError ? static_cast<const BaBLEError *>(payload()) : nullptr;
  }
  StatusCode status() const {
    return static_cast<StatusCode>(GetField<uint8_t>(VT_STATUS, 0));
  }
  uint8_t native_status() const {
    return GetField<uint8_t>(VT_NATIVE_STATUS, 0);
  }
  const flatbuffers::String *native_class() const {
    return GetPointer<const flatbuffers::String *>(VT_NATIVE_CLASS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PAYLOAD_TYPE) &&
           VerifyOffset(verifier, VT_PAYLOAD) &&
           VerifyPayload(verifier, payload(), payload_type()) &&
           VerifyField<uint8_t>(verifier, VT_STATUS) &&
           VerifyField<uint8_t>(verifier, VT_NATIVE_STATUS) &&
           VerifyOffset(verifier, VT_NATIVE_CLASS) &&
           verifier.Verify(native_class()) &&
           verifier.EndTable();
  }
};

template<> inline const AddDevice *Packet::payload_as<AddDevice>() const {
  return payload_as_AddDevice();
}

template<> inline const Disconnect *Packet::payload_as<Disconnect>() const {
  return payload_as_Disconnect();
}

template<> inline const GetMGMTInfo *Packet::payload_as<GetMGMTInfo>() const {
  return payload_as_GetMGMTInfo();
}

template<> inline const RemoveDevice *Packet::payload_as<RemoveDevice>() const {
  return payload_as_RemoveDevice();
}

template<> inline const SetPowered *Packet::payload_as<SetPowered>() const {
  return payload_as_SetPowered();
}

template<> inline const StartScan *Packet::payload_as<StartScan>() const {
  return payload_as_StartScan();
}

template<> inline const StopScan *Packet::payload_as<StopScan>() const {
  return payload_as_StopScan();
}

template<> inline const DeviceConnected *Packet::payload_as<DeviceConnected>() const {
  return payload_as_DeviceConnected();
}

template<> inline const DeviceDisconnected *Packet::payload_as<DeviceDisconnected>() const {
  return payload_as_DeviceDisconnected();
}

template<> inline const DeviceFound *Packet::payload_as<DeviceFound>() const {
  return payload_as_DeviceFound();
}

template<> inline const Discovering *Packet::payload_as<Discovering>() const {
  return payload_as_Discovering();
}

template<> inline const BaBLEError *Packet::payload_as<BaBLEError>() const {
  return payload_as_BaBLEError();
}

struct PacketBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_payload_type(Payload payload_type) {
    fbb_.AddElement<uint8_t>(Packet::VT_PAYLOAD_TYPE, static_cast<uint8_t>(payload_type), 0);
  }
  void add_payload(flatbuffers::Offset<void> payload) {
    fbb_.AddOffset(Packet::VT_PAYLOAD, payload);
  }
  void add_status(StatusCode status) {
    fbb_.AddElement<uint8_t>(Packet::VT_STATUS, static_cast<uint8_t>(status), 0);
  }
  void add_native_status(uint8_t native_status) {
    fbb_.AddElement<uint8_t>(Packet::VT_NATIVE_STATUS, native_status, 0);
  }
  void add_native_class(flatbuffers::Offset<flatbuffers::String> native_class) {
    fbb_.AddOffset(Packet::VT_NATIVE_CLASS, native_class);
  }
  explicit PacketBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PacketBuilder &operator=(const PacketBuilder &);
  flatbuffers::Offset<Packet> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Packet>(end);
    return o;
  }
};

inline flatbuffers::Offset<Packet> CreatePacket(
    flatbuffers::FlatBufferBuilder &_fbb,
    Payload payload_type = Payload::NONE,
    flatbuffers::Offset<void> payload = 0,
    StatusCode status = StatusCode::Success,
    uint8_t native_status = 0,
    flatbuffers::Offset<flatbuffers::String> native_class = 0) {
  PacketBuilder builder_(_fbb);
  builder_.add_native_class(native_class);
  builder_.add_payload(payload);
  builder_.add_native_status(native_status);
  builder_.add_status(status);
  builder_.add_payload_type(payload_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Packet> CreatePacketDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    Payload payload_type = Payload::NONE,
    flatbuffers::Offset<void> payload = 0,
    StatusCode status = StatusCode::Success,
    uint8_t native_status = 0,
    const char *native_class = nullptr) {
  return Schemas::CreatePacket(
      _fbb,
      payload_type,
      payload,
      status,
      native_status,
      native_class ? _fbb.CreateString(native_class) : 0);
}

inline bool VerifyPayload(flatbuffers::Verifier &verifier, const void *obj, Payload type) {
  switch (type) {
    case Payload::NONE: {
      return true;
    }
    case Payload::AddDevice: {
      auto ptr = reinterpret_cast<const AddDevice *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::Disconnect: {
      auto ptr = reinterpret_cast<const Disconnect *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::GetMGMTInfo: {
      auto ptr = reinterpret_cast<const GetMGMTInfo *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::RemoveDevice: {
      auto ptr = reinterpret_cast<const RemoveDevice *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::SetPowered: {
      auto ptr = reinterpret_cast<const SetPowered *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::StartScan: {
      auto ptr = reinterpret_cast<const StartScan *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::StopScan: {
      auto ptr = reinterpret_cast<const StopScan *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::DeviceConnected: {
      auto ptr = reinterpret_cast<const DeviceConnected *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::DeviceDisconnected: {
      auto ptr = reinterpret_cast<const DeviceDisconnected *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::DeviceFound: {
      auto ptr = reinterpret_cast<const DeviceFound *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::Discovering: {
      auto ptr = reinterpret_cast<const Discovering *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::BaBLEError: {
      auto ptr = reinterpret_cast<const BaBLEError *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyPayloadVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyPayload(
        verifier,  values->Get(i), types->GetEnum<Payload>(i))) {
      return false;
    }
  }
  return true;
}

inline const Schemas::Packet *GetPacket(const void *buf) {
  return flatbuffers::GetRoot<Schemas::Packet>(buf);
}

inline const Schemas::Packet *GetSizePrefixedPacket(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<Schemas::Packet>(buf);
}

inline bool VerifyPacketBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Schemas::Packet>(nullptr);
}

inline bool VerifySizePrefixedPacketBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Schemas::Packet>(nullptr);
}

inline void FinishPacketBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Schemas::Packet> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedPacketBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Schemas::Packet> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace Schemas

#endif  // FLATBUFFERS_GENERATED_PACKET_SCHEMAS_H_
