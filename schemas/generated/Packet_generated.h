// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_PACKET_SCHEMAS_H_
#define FLATBUFFERS_GENERATED_PACKET_SCHEMAS_H_

#include "flatbuffers/flatbuffers.h"

namespace Schemas {

struct GetMGMTInfo;

struct StartScan;

struct StopScan;

struct DeviceFound;

struct Discovering;

struct Packet;

enum class Payload : uint8_t {
  NONE = 0,
  GetMGMTInfo = 1,
  StartScan = 2,
  StopScan = 3,
  DeviceFound = 4,
  Discovering = 5,
  MIN = NONE,
  MAX = Discovering
};

inline const Payload (&EnumValuesPayload())[6] {
  static const Payload values[] = {
    Payload::NONE,
    Payload::GetMGMTInfo,
    Payload::StartScan,
    Payload::StopScan,
    Payload::DeviceFound,
    Payload::Discovering
  };
  return values;
}

inline const char * const *EnumNamesPayload() {
  static const char * const names[] = {
    "NONE",
    "GetMGMTInfo",
    "StartScan",
    "StopScan",
    "DeviceFound",
    "Discovering",
    nullptr
  };
  return names;
}

inline const char *EnumNamePayload(Payload e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesPayload()[index];
}

template<typename T> struct PayloadTraits {
  static const Payload enum_value = Payload::NONE;
};

template<> struct PayloadTraits<GetMGMTInfo> {
  static const Payload enum_value = Payload::GetMGMTInfo;
};

template<> struct PayloadTraits<StartScan> {
  static const Payload enum_value = Payload::StartScan;
};

template<> struct PayloadTraits<StopScan> {
  static const Payload enum_value = Payload::StopScan;
};

template<> struct PayloadTraits<DeviceFound> {
  static const Payload enum_value = Payload::DeviceFound;
};

template<> struct PayloadTraits<Discovering> {
  static const Payload enum_value = Payload::Discovering;
};

bool VerifyPayload(flatbuffers::Verifier &verifier, const void *obj, Payload type);
bool VerifyPayloadVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct GetMGMTInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VERSION = 4,
    VT_REVISION = 6
  };
  uint8_t version() const {
    return GetField<uint8_t>(VT_VERSION, 0);
  }
  uint16_t revision() const {
    return GetField<uint16_t>(VT_REVISION, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VERSION) &&
           VerifyField<uint16_t>(verifier, VT_REVISION) &&
           verifier.EndTable();
  }
};

struct GetMGMTInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_version(uint8_t version) {
    fbb_.AddElement<uint8_t>(GetMGMTInfo::VT_VERSION, version, 0);
  }
  void add_revision(uint16_t revision) {
    fbb_.AddElement<uint16_t>(GetMGMTInfo::VT_REVISION, revision, 0);
  }
  explicit GetMGMTInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GetMGMTInfoBuilder &operator=(const GetMGMTInfoBuilder &);
  flatbuffers::Offset<GetMGMTInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GetMGMTInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<GetMGMTInfo> CreateGetMGMTInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t version = 0,
    uint16_t revision = 0) {
  GetMGMTInfoBuilder builder_(_fbb);
  builder_.add_revision(revision);
  builder_.add_version(version);
  return builder_.Finish();
}

struct StartScan FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CONTROLLER_ID = 4,
    VT_ADDRESS_TYPE = 6
  };
  uint16_t controller_id() const {
    return GetField<uint16_t>(VT_CONTROLLER_ID, 0);
  }
  uint8_t address_type() const {
    return GetField<uint8_t>(VT_ADDRESS_TYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_CONTROLLER_ID) &&
           VerifyField<uint8_t>(verifier, VT_ADDRESS_TYPE) &&
           verifier.EndTable();
  }
};

struct StartScanBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_controller_id(uint16_t controller_id) {
    fbb_.AddElement<uint16_t>(StartScan::VT_CONTROLLER_ID, controller_id, 0);
  }
  void add_address_type(uint8_t address_type) {
    fbb_.AddElement<uint8_t>(StartScan::VT_ADDRESS_TYPE, address_type, 0);
  }
  explicit StartScanBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StartScanBuilder &operator=(const StartScanBuilder &);
  flatbuffers::Offset<StartScan> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StartScan>(end);
    return o;
  }
};

inline flatbuffers::Offset<StartScan> CreateStartScan(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t controller_id = 0,
    uint8_t address_type = 0) {
  StartScanBuilder builder_(_fbb);
  builder_.add_controller_id(controller_id);
  builder_.add_address_type(address_type);
  return builder_.Finish();
}

struct StopScan FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CONTROLLER_ID = 4,
    VT_ADDRESS_TYPE = 6
  };
  uint16_t controller_id() const {
    return GetField<uint16_t>(VT_CONTROLLER_ID, 0);
  }
  uint8_t address_type() const {
    return GetField<uint8_t>(VT_ADDRESS_TYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_CONTROLLER_ID) &&
           VerifyField<uint8_t>(verifier, VT_ADDRESS_TYPE) &&
           verifier.EndTable();
  }
};

struct StopScanBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_controller_id(uint16_t controller_id) {
    fbb_.AddElement<uint16_t>(StopScan::VT_CONTROLLER_ID, controller_id, 0);
  }
  void add_address_type(uint8_t address_type) {
    fbb_.AddElement<uint8_t>(StopScan::VT_ADDRESS_TYPE, address_type, 0);
  }
  explicit StopScanBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StopScanBuilder &operator=(const StopScanBuilder &);
  flatbuffers::Offset<StopScan> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StopScan>(end);
    return o;
  }
};

inline flatbuffers::Offset<StopScan> CreateStopScan(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t controller_id = 0,
    uint8_t address_type = 0) {
  StopScanBuilder builder_(_fbb);
  builder_.add_controller_id(controller_id);
  builder_.add_address_type(address_type);
  return builder_.Finish();
}

struct DeviceFound FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CONTROLLER_ID = 4,
    VT_ADDRESS = 6,
    VT_ADDRESS_TYPE = 8,
    VT_RSSI = 10,
    VT_FLAGS = 12,
    VT_UUID = 14,
    VT_COMPANY_ID = 16,
    VT_DEVICE_NAME = 18
  };
  uint16_t controller_id() const {
    return GetField<uint16_t>(VT_CONTROLLER_ID, 0);
  }
  const flatbuffers::String *address() const {
    return GetPointer<const flatbuffers::String *>(VT_ADDRESS);
  }
  uint8_t address_type() const {
    return GetField<uint8_t>(VT_ADDRESS_TYPE, 0);
  }
  int8_t rssi() const {
    return GetField<int8_t>(VT_RSSI, 0);
  }
  const flatbuffers::Vector<uint8_t> *flags() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_FLAGS);
  }
  const flatbuffers::String *uuid() const {
    return GetPointer<const flatbuffers::String *>(VT_UUID);
  }
  uint16_t company_id() const {
    return GetField<uint16_t>(VT_COMPANY_ID, 0);
  }
  const flatbuffers::String *device_name() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICE_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_CONTROLLER_ID) &&
           VerifyOffset(verifier, VT_ADDRESS) &&
           verifier.Verify(address()) &&
           VerifyField<uint8_t>(verifier, VT_ADDRESS_TYPE) &&
           VerifyField<int8_t>(verifier, VT_RSSI) &&
           VerifyOffset(verifier, VT_FLAGS) &&
           verifier.Verify(flags()) &&
           VerifyOffset(verifier, VT_UUID) &&
           verifier.Verify(uuid()) &&
           VerifyField<uint16_t>(verifier, VT_COMPANY_ID) &&
           VerifyOffset(verifier, VT_DEVICE_NAME) &&
           verifier.Verify(device_name()) &&
           verifier.EndTable();
  }
};

struct DeviceFoundBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_controller_id(uint16_t controller_id) {
    fbb_.AddElement<uint16_t>(DeviceFound::VT_CONTROLLER_ID, controller_id, 0);
  }
  void add_address(flatbuffers::Offset<flatbuffers::String> address) {
    fbb_.AddOffset(DeviceFound::VT_ADDRESS, address);
  }
  void add_address_type(uint8_t address_type) {
    fbb_.AddElement<uint8_t>(DeviceFound::VT_ADDRESS_TYPE, address_type, 0);
  }
  void add_rssi(int8_t rssi) {
    fbb_.AddElement<int8_t>(DeviceFound::VT_RSSI, rssi, 0);
  }
  void add_flags(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> flags) {
    fbb_.AddOffset(DeviceFound::VT_FLAGS, flags);
  }
  void add_uuid(flatbuffers::Offset<flatbuffers::String> uuid) {
    fbb_.AddOffset(DeviceFound::VT_UUID, uuid);
  }
  void add_company_id(uint16_t company_id) {
    fbb_.AddElement<uint16_t>(DeviceFound::VT_COMPANY_ID, company_id, 0);
  }
  void add_device_name(flatbuffers::Offset<flatbuffers::String> device_name) {
    fbb_.AddOffset(DeviceFound::VT_DEVICE_NAME, device_name);
  }
  explicit DeviceFoundBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DeviceFoundBuilder &operator=(const DeviceFoundBuilder &);
  flatbuffers::Offset<DeviceFound> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DeviceFound>(end);
    return o;
  }
};

inline flatbuffers::Offset<DeviceFound> CreateDeviceFound(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t controller_id = 0,
    flatbuffers::Offset<flatbuffers::String> address = 0,
    uint8_t address_type = 0,
    int8_t rssi = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> flags = 0,
    flatbuffers::Offset<flatbuffers::String> uuid = 0,
    uint16_t company_id = 0,
    flatbuffers::Offset<flatbuffers::String> device_name = 0) {
  DeviceFoundBuilder builder_(_fbb);
  builder_.add_device_name(device_name);
  builder_.add_uuid(uuid);
  builder_.add_flags(flags);
  builder_.add_address(address);
  builder_.add_company_id(company_id);
  builder_.add_controller_id(controller_id);
  builder_.add_rssi(rssi);
  builder_.add_address_type(address_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<DeviceFound> CreateDeviceFoundDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t controller_id = 0,
    const char *address = nullptr,
    uint8_t address_type = 0,
    int8_t rssi = 0,
    const std::vector<uint8_t> *flags = nullptr,
    const char *uuid = nullptr,
    uint16_t company_id = 0,
    const char *device_name = nullptr) {
  return Schemas::CreateDeviceFound(
      _fbb,
      controller_id,
      address ? _fbb.CreateString(address) : 0,
      address_type,
      rssi,
      flags ? _fbb.CreateVector<uint8_t>(*flags) : 0,
      uuid ? _fbb.CreateString(uuid) : 0,
      company_id,
      device_name ? _fbb.CreateString(device_name) : 0);
}

struct Discovering FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CONTROLLER_ID = 4,
    VT_ADDRESS_TYPE = 6,
    VT_STATE = 8
  };
  uint16_t controller_id() const {
    return GetField<uint16_t>(VT_CONTROLLER_ID, 0);
  }
  uint8_t address_type() const {
    return GetField<uint8_t>(VT_ADDRESS_TYPE, 0);
  }
  bool state() const {
    return GetField<uint8_t>(VT_STATE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_CONTROLLER_ID) &&
           VerifyField<uint8_t>(verifier, VT_ADDRESS_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_STATE) &&
           verifier.EndTable();
  }
};

struct DiscoveringBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_controller_id(uint16_t controller_id) {
    fbb_.AddElement<uint16_t>(Discovering::VT_CONTROLLER_ID, controller_id, 0);
  }
  void add_address_type(uint8_t address_type) {
    fbb_.AddElement<uint8_t>(Discovering::VT_ADDRESS_TYPE, address_type, 0);
  }
  void add_state(bool state) {
    fbb_.AddElement<uint8_t>(Discovering::VT_STATE, static_cast<uint8_t>(state), 0);
  }
  explicit DiscoveringBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DiscoveringBuilder &operator=(const DiscoveringBuilder &);
  flatbuffers::Offset<Discovering> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Discovering>(end);
    return o;
  }
};

inline flatbuffers::Offset<Discovering> CreateDiscovering(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t controller_id = 0,
    uint8_t address_type = 0,
    bool state = false) {
  DiscoveringBuilder builder_(_fbb);
  builder_.add_controller_id(controller_id);
  builder_.add_state(state);
  builder_.add_address_type(address_type);
  return builder_.Finish();
}

struct Packet FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PAYLOAD_TYPE = 4,
    VT_PAYLOAD = 6
  };
  Payload payload_type() const {
    return static_cast<Payload>(GetField<uint8_t>(VT_PAYLOAD_TYPE, 0));
  }
  const void *payload() const {
    return GetPointer<const void *>(VT_PAYLOAD);
  }
  template<typename T> const T *payload_as() const;
  const GetMGMTInfo *payload_as_GetMGMTInfo() const {
    return payload_type() == Payload::GetMGMTInfo ? static_cast<const GetMGMTInfo *>(payload()) : nullptr;
  }
  const StartScan *payload_as_StartScan() const {
    return payload_type() == Payload::StartScan ? static_cast<const StartScan *>(payload()) : nullptr;
  }
  const StopScan *payload_as_StopScan() const {
    return payload_type() == Payload::StopScan ? static_cast<const StopScan *>(payload()) : nullptr;
  }
  const DeviceFound *payload_as_DeviceFound() const {
    return payload_type() == Payload::DeviceFound ? static_cast<const DeviceFound *>(payload()) : nullptr;
  }
  const Discovering *payload_as_Discovering() const {
    return payload_type() == Payload::Discovering ? static_cast<const Discovering *>(payload()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PAYLOAD_TYPE) &&
           VerifyOffset(verifier, VT_PAYLOAD) &&
           VerifyPayload(verifier, payload(), payload_type()) &&
           verifier.EndTable();
  }
};

template<> inline const GetMGMTInfo *Packet::payload_as<GetMGMTInfo>() const {
  return payload_as_GetMGMTInfo();
}

template<> inline const StartScan *Packet::payload_as<StartScan>() const {
  return payload_as_StartScan();
}

template<> inline const StopScan *Packet::payload_as<StopScan>() const {
  return payload_as_StopScan();
}

template<> inline const DeviceFound *Packet::payload_as<DeviceFound>() const {
  return payload_as_DeviceFound();
}

template<> inline const Discovering *Packet::payload_as<Discovering>() const {
  return payload_as_Discovering();
}

struct PacketBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_payload_type(Payload payload_type) {
    fbb_.AddElement<uint8_t>(Packet::VT_PAYLOAD_TYPE, static_cast<uint8_t>(payload_type), 0);
  }
  void add_payload(flatbuffers::Offset<void> payload) {
    fbb_.AddOffset(Packet::VT_PAYLOAD, payload);
  }
  explicit PacketBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PacketBuilder &operator=(const PacketBuilder &);
  flatbuffers::Offset<Packet> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Packet>(end);
    return o;
  }
};

inline flatbuffers::Offset<Packet> CreatePacket(
    flatbuffers::FlatBufferBuilder &_fbb,
    Payload payload_type = Payload::NONE,
    flatbuffers::Offset<void> payload = 0) {
  PacketBuilder builder_(_fbb);
  builder_.add_payload(payload);
  builder_.add_payload_type(payload_type);
  return builder_.Finish();
}

inline bool VerifyPayload(flatbuffers::Verifier &verifier, const void *obj, Payload type) {
  switch (type) {
    case Payload::NONE: {
      return true;
    }
    case Payload::GetMGMTInfo: {
      auto ptr = reinterpret_cast<const GetMGMTInfo *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::StartScan: {
      auto ptr = reinterpret_cast<const StartScan *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::StopScan: {
      auto ptr = reinterpret_cast<const StopScan *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::DeviceFound: {
      auto ptr = reinterpret_cast<const DeviceFound *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::Discovering: {
      auto ptr = reinterpret_cast<const Discovering *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyPayloadVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyPayload(
        verifier,  values->Get(i), types->GetEnum<Payload>(i))) {
      return false;
    }
  }
  return true;
}

inline const Schemas::Packet *GetPacket(const void *buf) {
  return flatbuffers::GetRoot<Schemas::Packet>(buf);
}

inline const Schemas::Packet *GetSizePrefixedPacket(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<Schemas::Packet>(buf);
}

inline bool VerifyPacketBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Schemas::Packet>(nullptr);
}

inline bool VerifySizePrefixedPacketBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Schemas::Packet>(nullptr);
}

inline void FinishPacketBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Schemas::Packet> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedPacketBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Schemas::Packet> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace Schemas

#endif  // FLATBUFFERS_GENERATED_PACKET_SCHEMAS_H_
