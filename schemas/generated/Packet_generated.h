// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_PACKET_BABLE_H_
#define FLATBUFFERS_GENERATED_PACKET_BABLE_H_

#include "flatbuffers/flatbuffers.h"

namespace BaBLE {

struct GetMGMTInfo;

struct Controller;

struct GetControllersList;

struct GetControllersIds;

struct GetControllerInfo;

struct GetConnectedDevices;

struct StartScan;

struct StopScan;

struct AddDevice;

struct RemoveDevice;

struct Disconnect;

struct SetPowered;

struct SetDiscoverable;

struct SetConnectable;

struct Read;

struct Write;

struct WriteWithoutResponse;

struct Service;

struct ProbeServices;

struct Characteristic;

struct ProbeCharacteristics;

struct DeviceConnected;

struct DeviceDisconnected;

struct DeviceFound;

struct Discovering;

struct ControllerAdded;

struct ControllerRemoved;

struct NotificationReceived;

struct BaBLEError;

struct Ready;

struct Exit;

struct Packet;

enum class Payload : uint8_t {
  NONE = 0,
  AddDevice = 1,
  Disconnect = 2,
  GetConnectedDevices = 3,
  GetControllersIds = 4,
  GetControllerInfo = 5,
  GetControllersList = 6,
  GetMGMTInfo = 7,
  ProbeCharacteristics = 8,
  ProbeServices = 9,
  Read = 10,
  RemoveDevice = 11,
  SetConnectable = 12,
  SetDiscoverable = 13,
  SetPowered = 14,
  StartScan = 15,
  StopScan = 16,
  Write = 17,
  WriteWithoutResponse = 18,
  ControllerAdded = 19,
  ControllerRemoved = 20,
  DeviceConnected = 21,
  DeviceDisconnected = 22,
  DeviceFound = 23,
  Discovering = 24,
  NotificationReceived = 25,
  BaBLEError = 26,
  Exit = 27,
  Ready = 28,
  MIN = NONE,
  MAX = Ready
};

inline const Payload (&EnumValuesPayload())[29] {
  static const Payload values[] = {
    Payload::NONE,
    Payload::AddDevice,
    Payload::Disconnect,
    Payload::GetConnectedDevices,
    Payload::GetControllersIds,
    Payload::GetControllerInfo,
    Payload::GetControllersList,
    Payload::GetMGMTInfo,
    Payload::ProbeCharacteristics,
    Payload::ProbeServices,
    Payload::Read,
    Payload::RemoveDevice,
    Payload::SetConnectable,
    Payload::SetDiscoverable,
    Payload::SetPowered,
    Payload::StartScan,
    Payload::StopScan,
    Payload::Write,
    Payload::WriteWithoutResponse,
    Payload::ControllerAdded,
    Payload::ControllerRemoved,
    Payload::DeviceConnected,
    Payload::DeviceDisconnected,
    Payload::DeviceFound,
    Payload::Discovering,
    Payload::NotificationReceived,
    Payload::BaBLEError,
    Payload::Exit,
    Payload::Ready
  };
  return values;
}

inline const char * const *EnumNamesPayload() {
  static const char * const names[] = {
    "NONE",
    "AddDevice",
    "Disconnect",
    "GetConnectedDevices",
    "GetControllersIds",
    "GetControllerInfo",
    "GetControllersList",
    "GetMGMTInfo",
    "ProbeCharacteristics",
    "ProbeServices",
    "Read",
    "RemoveDevice",
    "SetConnectable",
    "SetDiscoverable",
    "SetPowered",
    "StartScan",
    "StopScan",
    "Write",
    "WriteWithoutResponse",
    "ControllerAdded",
    "ControllerRemoved",
    "DeviceConnected",
    "DeviceDisconnected",
    "DeviceFound",
    "Discovering",
    "NotificationReceived",
    "BaBLEError",
    "Exit",
    "Ready",
    nullptr
  };
  return names;
}

inline const char *EnumNamePayload(Payload e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesPayload()[index];
}

template<typename T> struct PayloadTraits {
  static const Payload enum_value = Payload::NONE;
};

template<> struct PayloadTraits<AddDevice> {
  static const Payload enum_value = Payload::AddDevice;
};

template<> struct PayloadTraits<Disconnect> {
  static const Payload enum_value = Payload::Disconnect;
};

template<> struct PayloadTraits<GetConnectedDevices> {
  static const Payload enum_value = Payload::GetConnectedDevices;
};

template<> struct PayloadTraits<GetControllersIds> {
  static const Payload enum_value = Payload::GetControllersIds;
};

template<> struct PayloadTraits<GetControllerInfo> {
  static const Payload enum_value = Payload::GetControllerInfo;
};

template<> struct PayloadTraits<GetControllersList> {
  static const Payload enum_value = Payload::GetControllersList;
};

template<> struct PayloadTraits<GetMGMTInfo> {
  static const Payload enum_value = Payload::GetMGMTInfo;
};

template<> struct PayloadTraits<ProbeCharacteristics> {
  static const Payload enum_value = Payload::ProbeCharacteristics;
};

template<> struct PayloadTraits<ProbeServices> {
  static const Payload enum_value = Payload::ProbeServices;
};

template<> struct PayloadTraits<Read> {
  static const Payload enum_value = Payload::Read;
};

template<> struct PayloadTraits<RemoveDevice> {
  static const Payload enum_value = Payload::RemoveDevice;
};

template<> struct PayloadTraits<SetConnectable> {
  static const Payload enum_value = Payload::SetConnectable;
};

template<> struct PayloadTraits<SetDiscoverable> {
  static const Payload enum_value = Payload::SetDiscoverable;
};

template<> struct PayloadTraits<SetPowered> {
  static const Payload enum_value = Payload::SetPowered;
};

template<> struct PayloadTraits<StartScan> {
  static const Payload enum_value = Payload::StartScan;
};

template<> struct PayloadTraits<StopScan> {
  static const Payload enum_value = Payload::StopScan;
};

template<> struct PayloadTraits<Write> {
  static const Payload enum_value = Payload::Write;
};

template<> struct PayloadTraits<WriteWithoutResponse> {
  static const Payload enum_value = Payload::WriteWithoutResponse;
};

template<> struct PayloadTraits<ControllerAdded> {
  static const Payload enum_value = Payload::ControllerAdded;
};

template<> struct PayloadTraits<ControllerRemoved> {
  static const Payload enum_value = Payload::ControllerRemoved;
};

template<> struct PayloadTraits<DeviceConnected> {
  static const Payload enum_value = Payload::DeviceConnected;
};

template<> struct PayloadTraits<DeviceDisconnected> {
  static const Payload enum_value = Payload::DeviceDisconnected;
};

template<> struct PayloadTraits<DeviceFound> {
  static const Payload enum_value = Payload::DeviceFound;
};

template<> struct PayloadTraits<Discovering> {
  static const Payload enum_value = Payload::Discovering;
};

template<> struct PayloadTraits<NotificationReceived> {
  static const Payload enum_value = Payload::NotificationReceived;
};

template<> struct PayloadTraits<BaBLEError> {
  static const Payload enum_value = Payload::BaBLEError;
};

template<> struct PayloadTraits<Exit> {
  static const Payload enum_value = Payload::Exit;
};

template<> struct PayloadTraits<Ready> {
  static const Payload enum_value = Payload::Ready;
};

bool VerifyPayload(flatbuffers::Verifier &verifier, const void *obj, Payload type);
bool VerifyPayloadVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class StatusCode : uint8_t {
  Success = 0,
  SocketError = 1,
  NotFound = 2,
  WrongFormat = 3,
  InvalidCommand = 4,
  Unknown = 5,
  Rejected = 6,
  Denied = 7,
  Cancelled = 8,
  NotPowered = 9,
  Failed = 10,
  NotConnected = 11,
  MIN = Success,
  MAX = NotConnected
};

inline const StatusCode (&EnumValuesStatusCode())[12] {
  static const StatusCode values[] = {
    StatusCode::Success,
    StatusCode::SocketError,
    StatusCode::NotFound,
    StatusCode::WrongFormat,
    StatusCode::InvalidCommand,
    StatusCode::Unknown,
    StatusCode::Rejected,
    StatusCode::Denied,
    StatusCode::Cancelled,
    StatusCode::NotPowered,
    StatusCode::Failed,
    StatusCode::NotConnected
  };
  return values;
}

inline const char * const *EnumNamesStatusCode() {
  static const char * const names[] = {
    "Success",
    "SocketError",
    "NotFound",
    "WrongFormat",
    "InvalidCommand",
    "Unknown",
    "Rejected",
    "Denied",
    "Cancelled",
    "NotPowered",
    "Failed",
    "NotConnected",
    nullptr
  };
  return names;
}

inline const char *EnumNameStatusCode(StatusCode e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesStatusCode()[index];
}

struct GetMGMTInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VERSION = 4,
    VT_REVISION = 6
  };
  uint8_t version() const {
    return GetField<uint8_t>(VT_VERSION, 0);
  }
  uint16_t revision() const {
    return GetField<uint16_t>(VT_REVISION, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VERSION) &&
           VerifyField<uint16_t>(verifier, VT_REVISION) &&
           verifier.EndTable();
  }
};

struct GetMGMTInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_version(uint8_t version) {
    fbb_.AddElement<uint8_t>(GetMGMTInfo::VT_VERSION, version, 0);
  }
  void add_revision(uint16_t revision) {
    fbb_.AddElement<uint16_t>(GetMGMTInfo::VT_REVISION, revision, 0);
  }
  explicit GetMGMTInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GetMGMTInfoBuilder &operator=(const GetMGMTInfoBuilder &);
  flatbuffers::Offset<GetMGMTInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GetMGMTInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<GetMGMTInfo> CreateGetMGMTInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t version = 0,
    uint16_t revision = 0) {
  GetMGMTInfoBuilder builder_(_fbb);
  builder_.add_revision(revision);
  builder_.add_version(version);
  return builder_.Finish();
}

struct Controller FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_ADDRESS = 6,
    VT_BT_VERSION = 8,
    VT_POWERED = 10,
    VT_CONNECTABLE = 12,
    VT_DISCOVERABLE = 14,
    VT_LOW_ENERGY = 16,
    VT_NAME = 18
  };
  uint16_t id() const {
    return GetField<uint16_t>(VT_ID, 0);
  }
  const flatbuffers::String *address() const {
    return GetPointer<const flatbuffers::String *>(VT_ADDRESS);
  }
  uint8_t bt_version() const {
    return GetField<uint8_t>(VT_BT_VERSION, 0);
  }
  bool powered() const {
    return GetField<uint8_t>(VT_POWERED, 0) != 0;
  }
  bool connectable() const {
    return GetField<uint8_t>(VT_CONNECTABLE, 0) != 0;
  }
  bool discoverable() const {
    return GetField<uint8_t>(VT_DISCOVERABLE, 0) != 0;
  }
  bool low_energy() const {
    return GetField<uint8_t>(VT_LOW_ENERGY, 0) != 0;
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ID) &&
           VerifyOffset(verifier, VT_ADDRESS) &&
           verifier.Verify(address()) &&
           VerifyField<uint8_t>(verifier, VT_BT_VERSION) &&
           VerifyField<uint8_t>(verifier, VT_POWERED) &&
           VerifyField<uint8_t>(verifier, VT_CONNECTABLE) &&
           VerifyField<uint8_t>(verifier, VT_DISCOVERABLE) &&
           VerifyField<uint8_t>(verifier, VT_LOW_ENERGY) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           verifier.EndTable();
  }
};

struct ControllerBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint16_t id) {
    fbb_.AddElement<uint16_t>(Controller::VT_ID, id, 0);
  }
  void add_address(flatbuffers::Offset<flatbuffers::String> address) {
    fbb_.AddOffset(Controller::VT_ADDRESS, address);
  }
  void add_bt_version(uint8_t bt_version) {
    fbb_.AddElement<uint8_t>(Controller::VT_BT_VERSION, bt_version, 0);
  }
  void add_powered(bool powered) {
    fbb_.AddElement<uint8_t>(Controller::VT_POWERED, static_cast<uint8_t>(powered), 0);
  }
  void add_connectable(bool connectable) {
    fbb_.AddElement<uint8_t>(Controller::VT_CONNECTABLE, static_cast<uint8_t>(connectable), 0);
  }
  void add_discoverable(bool discoverable) {
    fbb_.AddElement<uint8_t>(Controller::VT_DISCOVERABLE, static_cast<uint8_t>(discoverable), 0);
  }
  void add_low_energy(bool low_energy) {
    fbb_.AddElement<uint8_t>(Controller::VT_LOW_ENERGY, static_cast<uint8_t>(low_energy), 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Controller::VT_NAME, name);
  }
  explicit ControllerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ControllerBuilder &operator=(const ControllerBuilder &);
  flatbuffers::Offset<Controller> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Controller>(end);
    return o;
  }
};

inline flatbuffers::Offset<Controller> CreateController(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t id = 0,
    flatbuffers::Offset<flatbuffers::String> address = 0,
    uint8_t bt_version = 0,
    bool powered = false,
    bool connectable = false,
    bool discoverable = false,
    bool low_energy = false,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  ControllerBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_address(address);
  builder_.add_id(id);
  builder_.add_low_energy(low_energy);
  builder_.add_discoverable(discoverable);
  builder_.add_connectable(connectable);
  builder_.add_powered(powered);
  builder_.add_bt_version(bt_version);
  return builder_.Finish();
}

inline flatbuffers::Offset<Controller> CreateControllerDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t id = 0,
    const char *address = nullptr,
    uint8_t bt_version = 0,
    bool powered = false,
    bool connectable = false,
    bool discoverable = false,
    bool low_energy = false,
    const char *name = nullptr) {
  return BaBLE::CreateController(
      _fbb,
      id,
      address ? _fbb.CreateString(address) : 0,
      bt_version,
      powered,
      connectable,
      discoverable,
      low_energy,
      name ? _fbb.CreateString(name) : 0);
}

struct GetControllersList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CONTROLLERS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<Controller>> *controllers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Controller>> *>(VT_CONTROLLERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONTROLLERS) &&
           verifier.Verify(controllers()) &&
           verifier.VerifyVectorOfTables(controllers()) &&
           verifier.EndTable();
  }
};

struct GetControllersListBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_controllers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Controller>>> controllers) {
    fbb_.AddOffset(GetControllersList::VT_CONTROLLERS, controllers);
  }
  explicit GetControllersListBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GetControllersListBuilder &operator=(const GetControllersListBuilder &);
  flatbuffers::Offset<GetControllersList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GetControllersList>(end);
    return o;
  }
};

inline flatbuffers::Offset<GetControllersList> CreateGetControllersList(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Controller>>> controllers = 0) {
  GetControllersListBuilder builder_(_fbb);
  builder_.add_controllers(controllers);
  return builder_.Finish();
}

inline flatbuffers::Offset<GetControllersList> CreateGetControllersListDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Controller>> *controllers = nullptr) {
  return BaBLE::CreateGetControllersList(
      _fbb,
      controllers ? _fbb.CreateVector<flatbuffers::Offset<Controller>>(*controllers) : 0);
}

struct GetControllersIds FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CONTROLLERS_IDS = 4
  };
  const flatbuffers::Vector<uint16_t> *controllers_ids() const {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_CONTROLLERS_IDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONTROLLERS_IDS) &&
           verifier.Verify(controllers_ids()) &&
           verifier.EndTable();
  }
};

struct GetControllersIdsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_controllers_ids(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> controllers_ids) {
    fbb_.AddOffset(GetControllersIds::VT_CONTROLLERS_IDS, controllers_ids);
  }
  explicit GetControllersIdsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GetControllersIdsBuilder &operator=(const GetControllersIdsBuilder &);
  flatbuffers::Offset<GetControllersIds> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GetControllersIds>(end);
    return o;
  }
};

inline flatbuffers::Offset<GetControllersIds> CreateGetControllersIds(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> controllers_ids = 0) {
  GetControllersIdsBuilder builder_(_fbb);
  builder_.add_controllers_ids(controllers_ids);
  return builder_.Finish();
}

inline flatbuffers::Offset<GetControllersIds> CreateGetControllersIdsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint16_t> *controllers_ids = nullptr) {
  return BaBLE::CreateGetControllersIds(
      _fbb,
      controllers_ids ? _fbb.CreateVector<uint16_t>(*controllers_ids) : 0);
}

struct GetControllerInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CONTROLLER_INFO = 4
  };
  const Controller *controller_info() const {
    return GetPointer<const Controller *>(VT_CONTROLLER_INFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONTROLLER_INFO) &&
           verifier.VerifyTable(controller_info()) &&
           verifier.EndTable();
  }
};

struct GetControllerInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_controller_info(flatbuffers::Offset<Controller> controller_info) {
    fbb_.AddOffset(GetControllerInfo::VT_CONTROLLER_INFO, controller_info);
  }
  explicit GetControllerInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GetControllerInfoBuilder &operator=(const GetControllerInfoBuilder &);
  flatbuffers::Offset<GetControllerInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GetControllerInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<GetControllerInfo> CreateGetControllerInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Controller> controller_info = 0) {
  GetControllerInfoBuilder builder_(_fbb);
  builder_.add_controller_info(controller_info);
  return builder_.Finish();
}

struct GetConnectedDevices FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DEVICES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *devices() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_DEVICES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DEVICES) &&
           verifier.Verify(devices()) &&
           verifier.VerifyVectorOfStrings(devices()) &&
           verifier.EndTable();
  }
};

struct GetConnectedDevicesBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_devices(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> devices) {
    fbb_.AddOffset(GetConnectedDevices::VT_DEVICES, devices);
  }
  explicit GetConnectedDevicesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GetConnectedDevicesBuilder &operator=(const GetConnectedDevicesBuilder &);
  flatbuffers::Offset<GetConnectedDevices> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GetConnectedDevices>(end);
    return o;
  }
};

inline flatbuffers::Offset<GetConnectedDevices> CreateGetConnectedDevices(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> devices = 0) {
  GetConnectedDevicesBuilder builder_(_fbb);
  builder_.add_devices(devices);
  return builder_.Finish();
}

inline flatbuffers::Offset<GetConnectedDevices> CreateGetConnectedDevicesDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *devices = nullptr) {
  return BaBLE::CreateGetConnectedDevices(
      _fbb,
      devices ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*devices) : 0);
}

struct StartScan FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ADDRESS_TYPE = 4
  };
  uint8_t address_type() const {
    return GetField<uint8_t>(VT_ADDRESS_TYPE, 6);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ADDRESS_TYPE) &&
           verifier.EndTable();
  }
};

struct StartScanBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_address_type(uint8_t address_type) {
    fbb_.AddElement<uint8_t>(StartScan::VT_ADDRESS_TYPE, address_type, 6);
  }
  explicit StartScanBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StartScanBuilder &operator=(const StartScanBuilder &);
  flatbuffers::Offset<StartScan> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StartScan>(end);
    return o;
  }
};

inline flatbuffers::Offset<StartScan> CreateStartScan(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t address_type = 6) {
  StartScanBuilder builder_(_fbb);
  builder_.add_address_type(address_type);
  return builder_.Finish();
}

struct StopScan FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ADDRESS_TYPE = 4
  };
  uint8_t address_type() const {
    return GetField<uint8_t>(VT_ADDRESS_TYPE, 6);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ADDRESS_TYPE) &&
           verifier.EndTable();
  }
};

struct StopScanBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_address_type(uint8_t address_type) {
    fbb_.AddElement<uint8_t>(StopScan::VT_ADDRESS_TYPE, address_type, 6);
  }
  explicit StopScanBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StopScanBuilder &operator=(const StopScanBuilder &);
  flatbuffers::Offset<StopScan> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StopScan>(end);
    return o;
  }
};

inline flatbuffers::Offset<StopScan> CreateStopScan(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t address_type = 6) {
  StopScanBuilder builder_(_fbb);
  builder_.add_address_type(address_type);
  return builder_.Finish();
}

struct AddDevice FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ADDRESS = 4,
    VT_ADDRESS_TYPE = 6
  };
  const flatbuffers::Vector<uint8_t> *address() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_ADDRESS);
  }
  uint8_t address_type() const {
    return GetField<uint8_t>(VT_ADDRESS_TYPE, 2);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ADDRESS) &&
           verifier.Verify(address()) &&
           VerifyField<uint8_t>(verifier, VT_ADDRESS_TYPE) &&
           verifier.EndTable();
  }
};

struct AddDeviceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_address(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> address) {
    fbb_.AddOffset(AddDevice::VT_ADDRESS, address);
  }
  void add_address_type(uint8_t address_type) {
    fbb_.AddElement<uint8_t>(AddDevice::VT_ADDRESS_TYPE, address_type, 2);
  }
  explicit AddDeviceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AddDeviceBuilder &operator=(const AddDeviceBuilder &);
  flatbuffers::Offset<AddDevice> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AddDevice>(end);
    return o;
  }
};

inline flatbuffers::Offset<AddDevice> CreateAddDevice(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> address = 0,
    uint8_t address_type = 2) {
  AddDeviceBuilder builder_(_fbb);
  builder_.add_address(address);
  builder_.add_address_type(address_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<AddDevice> CreateAddDeviceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *address = nullptr,
    uint8_t address_type = 2) {
  return BaBLE::CreateAddDevice(
      _fbb,
      address ? _fbb.CreateVector<uint8_t>(*address) : 0,
      address_type);
}

struct RemoveDevice FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ADDRESS = 4,
    VT_ADDRESS_TYPE = 6
  };
  const flatbuffers::Vector<uint8_t> *address() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_ADDRESS);
  }
  uint8_t address_type() const {
    return GetField<uint8_t>(VT_ADDRESS_TYPE, 2);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ADDRESS) &&
           verifier.Verify(address()) &&
           VerifyField<uint8_t>(verifier, VT_ADDRESS_TYPE) &&
           verifier.EndTable();
  }
};

struct RemoveDeviceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_address(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> address) {
    fbb_.AddOffset(RemoveDevice::VT_ADDRESS, address);
  }
  void add_address_type(uint8_t address_type) {
    fbb_.AddElement<uint8_t>(RemoveDevice::VT_ADDRESS_TYPE, address_type, 2);
  }
  explicit RemoveDeviceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RemoveDeviceBuilder &operator=(const RemoveDeviceBuilder &);
  flatbuffers::Offset<RemoveDevice> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RemoveDevice>(end);
    return o;
  }
};

inline flatbuffers::Offset<RemoveDevice> CreateRemoveDevice(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> address = 0,
    uint8_t address_type = 2) {
  RemoveDeviceBuilder builder_(_fbb);
  builder_.add_address(address);
  builder_.add_address_type(address_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<RemoveDevice> CreateRemoveDeviceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *address = nullptr,
    uint8_t address_type = 2) {
  return BaBLE::CreateRemoveDevice(
      _fbb,
      address ? _fbb.CreateVector<uint8_t>(*address) : 0,
      address_type);
}

struct Disconnect FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ADDRESS = 4,
    VT_ADDRESS_TYPE = 6
  };
  const flatbuffers::Vector<uint8_t> *address() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_ADDRESS);
  }
  uint8_t address_type() const {
    return GetField<uint8_t>(VT_ADDRESS_TYPE, 2);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ADDRESS) &&
           verifier.Verify(address()) &&
           VerifyField<uint8_t>(verifier, VT_ADDRESS_TYPE) &&
           verifier.EndTable();
  }
};

struct DisconnectBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_address(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> address) {
    fbb_.AddOffset(Disconnect::VT_ADDRESS, address);
  }
  void add_address_type(uint8_t address_type) {
    fbb_.AddElement<uint8_t>(Disconnect::VT_ADDRESS_TYPE, address_type, 2);
  }
  explicit DisconnectBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DisconnectBuilder &operator=(const DisconnectBuilder &);
  flatbuffers::Offset<Disconnect> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Disconnect>(end);
    return o;
  }
};

inline flatbuffers::Offset<Disconnect> CreateDisconnect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> address = 0,
    uint8_t address_type = 2) {
  DisconnectBuilder builder_(_fbb);
  builder_.add_address(address);
  builder_.add_address_type(address_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Disconnect> CreateDisconnectDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *address = nullptr,
    uint8_t address_type = 2) {
  return BaBLE::CreateDisconnect(
      _fbb,
      address ? _fbb.CreateVector<uint8_t>(*address) : 0,
      address_type);
}

struct SetPowered FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_STATE = 4
  };
  bool state() const {
    return GetField<uint8_t>(VT_STATE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_STATE) &&
           verifier.EndTable();
  }
};

struct SetPoweredBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_state(bool state) {
    fbb_.AddElement<uint8_t>(SetPowered::VT_STATE, static_cast<uint8_t>(state), 0);
  }
  explicit SetPoweredBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SetPoweredBuilder &operator=(const SetPoweredBuilder &);
  flatbuffers::Offset<SetPowered> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SetPowered>(end);
    return o;
  }
};

inline flatbuffers::Offset<SetPowered> CreateSetPowered(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool state = false) {
  SetPoweredBuilder builder_(_fbb);
  builder_.add_state(state);
  return builder_.Finish();
}

struct SetDiscoverable FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_STATE = 4,
    VT_TIMEOUT = 6
  };
  bool state() const {
    return GetField<uint8_t>(VT_STATE, 0) != 0;
  }
  uint16_t timeout() const {
    return GetField<uint16_t>(VT_TIMEOUT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_STATE) &&
           VerifyField<uint16_t>(verifier, VT_TIMEOUT) &&
           verifier.EndTable();
  }
};

struct SetDiscoverableBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_state(bool state) {
    fbb_.AddElement<uint8_t>(SetDiscoverable::VT_STATE, static_cast<uint8_t>(state), 0);
  }
  void add_timeout(uint16_t timeout) {
    fbb_.AddElement<uint16_t>(SetDiscoverable::VT_TIMEOUT, timeout, 0);
  }
  explicit SetDiscoverableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SetDiscoverableBuilder &operator=(const SetDiscoverableBuilder &);
  flatbuffers::Offset<SetDiscoverable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SetDiscoverable>(end);
    return o;
  }
};

inline flatbuffers::Offset<SetDiscoverable> CreateSetDiscoverable(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool state = false,
    uint16_t timeout = 0) {
  SetDiscoverableBuilder builder_(_fbb);
  builder_.add_timeout(timeout);
  builder_.add_state(state);
  return builder_.Finish();
}

struct SetConnectable FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_STATE = 4
  };
  bool state() const {
    return GetField<uint8_t>(VT_STATE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_STATE) &&
           verifier.EndTable();
  }
};

struct SetConnectableBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_state(bool state) {
    fbb_.AddElement<uint8_t>(SetConnectable::VT_STATE, static_cast<uint8_t>(state), 0);
  }
  explicit SetConnectableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SetConnectableBuilder &operator=(const SetConnectableBuilder &);
  flatbuffers::Offset<SetConnectable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SetConnectable>(end);
    return o;
  }
};

inline flatbuffers::Offset<SetConnectable> CreateSetConnectable(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool state = false) {
  SetConnectableBuilder builder_(_fbb);
  builder_.add_state(state);
  return builder_.Finish();
}

struct Read FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CONNECTION_HANDLE = 4,
    VT_ATTRIBUTE_HANDLE = 6,
    VT_VALUE = 8
  };
  uint16_t connection_handle() const {
    return GetField<uint16_t>(VT_CONNECTION_HANDLE, 0);
  }
  uint16_t attribute_handle() const {
    return GetField<uint16_t>(VT_ATTRIBUTE_HANDLE, 0);
  }
  const flatbuffers::Vector<uint8_t> *value() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_CONNECTION_HANDLE) &&
           VerifyField<uint16_t>(verifier, VT_ATTRIBUTE_HANDLE) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.Verify(value()) &&
           verifier.EndTable();
  }
};

struct ReadBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_connection_handle(uint16_t connection_handle) {
    fbb_.AddElement<uint16_t>(Read::VT_CONNECTION_HANDLE, connection_handle, 0);
  }
  void add_attribute_handle(uint16_t attribute_handle) {
    fbb_.AddElement<uint16_t>(Read::VT_ATTRIBUTE_HANDLE, attribute_handle, 0);
  }
  void add_value(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value) {
    fbb_.AddOffset(Read::VT_VALUE, value);
  }
  explicit ReadBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReadBuilder &operator=(const ReadBuilder &);
  flatbuffers::Offset<Read> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Read>(end);
    return o;
  }
};

inline flatbuffers::Offset<Read> CreateRead(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t connection_handle = 0,
    uint16_t attribute_handle = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value = 0) {
  ReadBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_attribute_handle(attribute_handle);
  builder_.add_connection_handle(connection_handle);
  return builder_.Finish();
}

inline flatbuffers::Offset<Read> CreateReadDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t connection_handle = 0,
    uint16_t attribute_handle = 0,
    const std::vector<uint8_t> *value = nullptr) {
  return BaBLE::CreateRead(
      _fbb,
      connection_handle,
      attribute_handle,
      value ? _fbb.CreateVector<uint8_t>(*value) : 0);
}

struct Write FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CONNECTION_HANDLE = 4,
    VT_ATTRIBUTE_HANDLE = 6,
    VT_VALUE = 8
  };
  uint16_t connection_handle() const {
    return GetField<uint16_t>(VT_CONNECTION_HANDLE, 0);
  }
  uint16_t attribute_handle() const {
    return GetField<uint16_t>(VT_ATTRIBUTE_HANDLE, 0);
  }
  const flatbuffers::Vector<uint8_t> *value() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_CONNECTION_HANDLE) &&
           VerifyField<uint16_t>(verifier, VT_ATTRIBUTE_HANDLE) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.Verify(value()) &&
           verifier.EndTable();
  }
};

struct WriteBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_connection_handle(uint16_t connection_handle) {
    fbb_.AddElement<uint16_t>(Write::VT_CONNECTION_HANDLE, connection_handle, 0);
  }
  void add_attribute_handle(uint16_t attribute_handle) {
    fbb_.AddElement<uint16_t>(Write::VT_ATTRIBUTE_HANDLE, attribute_handle, 0);
  }
  void add_value(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value) {
    fbb_.AddOffset(Write::VT_VALUE, value);
  }
  explicit WriteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WriteBuilder &operator=(const WriteBuilder &);
  flatbuffers::Offset<Write> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Write>(end);
    return o;
  }
};

inline flatbuffers::Offset<Write> CreateWrite(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t connection_handle = 0,
    uint16_t attribute_handle = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value = 0) {
  WriteBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_attribute_handle(attribute_handle);
  builder_.add_connection_handle(connection_handle);
  return builder_.Finish();
}

inline flatbuffers::Offset<Write> CreateWriteDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t connection_handle = 0,
    uint16_t attribute_handle = 0,
    const std::vector<uint8_t> *value = nullptr) {
  return BaBLE::CreateWrite(
      _fbb,
      connection_handle,
      attribute_handle,
      value ? _fbb.CreateVector<uint8_t>(*value) : 0);
}

struct WriteWithoutResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CONNECTION_HANDLE = 4,
    VT_ATTRIBUTE_HANDLE = 6,
    VT_VALUE = 8
  };
  uint16_t connection_handle() const {
    return GetField<uint16_t>(VT_CONNECTION_HANDLE, 0);
  }
  uint16_t attribute_handle() const {
    return GetField<uint16_t>(VT_ATTRIBUTE_HANDLE, 0);
  }
  const flatbuffers::Vector<uint8_t> *value() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_CONNECTION_HANDLE) &&
           VerifyField<uint16_t>(verifier, VT_ATTRIBUTE_HANDLE) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.Verify(value()) &&
           verifier.EndTable();
  }
};

struct WriteWithoutResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_connection_handle(uint16_t connection_handle) {
    fbb_.AddElement<uint16_t>(WriteWithoutResponse::VT_CONNECTION_HANDLE, connection_handle, 0);
  }
  void add_attribute_handle(uint16_t attribute_handle) {
    fbb_.AddElement<uint16_t>(WriteWithoutResponse::VT_ATTRIBUTE_HANDLE, attribute_handle, 0);
  }
  void add_value(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value) {
    fbb_.AddOffset(WriteWithoutResponse::VT_VALUE, value);
  }
  explicit WriteWithoutResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WriteWithoutResponseBuilder &operator=(const WriteWithoutResponseBuilder &);
  flatbuffers::Offset<WriteWithoutResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WriteWithoutResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<WriteWithoutResponse> CreateWriteWithoutResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t connection_handle = 0,
    uint16_t attribute_handle = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value = 0) {
  WriteWithoutResponseBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_attribute_handle(attribute_handle);
  builder_.add_connection_handle(connection_handle);
  return builder_.Finish();
}

inline flatbuffers::Offset<WriteWithoutResponse> CreateWriteWithoutResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t connection_handle = 0,
    uint16_t attribute_handle = 0,
    const std::vector<uint8_t> *value = nullptr) {
  return BaBLE::CreateWriteWithoutResponse(
      _fbb,
      connection_handle,
      attribute_handle,
      value ? _fbb.CreateVector<uint8_t>(*value) : 0);
}

struct Service FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_HANDLE = 4,
    VT_GROUP_END_HANDLE = 6,
    VT_UUID = 8
  };
  uint16_t handle() const {
    return GetField<uint16_t>(VT_HANDLE, 0);
  }
  uint16_t group_end_handle() const {
    return GetField<uint16_t>(VT_GROUP_END_HANDLE, 0);
  }
  const flatbuffers::String *uuid() const {
    return GetPointer<const flatbuffers::String *>(VT_UUID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_HANDLE) &&
           VerifyField<uint16_t>(verifier, VT_GROUP_END_HANDLE) &&
           VerifyOffset(verifier, VT_UUID) &&
           verifier.Verify(uuid()) &&
           verifier.EndTable();
  }
};

struct ServiceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_handle(uint16_t handle) {
    fbb_.AddElement<uint16_t>(Service::VT_HANDLE, handle, 0);
  }
  void add_group_end_handle(uint16_t group_end_handle) {
    fbb_.AddElement<uint16_t>(Service::VT_GROUP_END_HANDLE, group_end_handle, 0);
  }
  void add_uuid(flatbuffers::Offset<flatbuffers::String> uuid) {
    fbb_.AddOffset(Service::VT_UUID, uuid);
  }
  explicit ServiceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ServiceBuilder &operator=(const ServiceBuilder &);
  flatbuffers::Offset<Service> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Service>(end);
    return o;
  }
};

inline flatbuffers::Offset<Service> CreateService(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t handle = 0,
    uint16_t group_end_handle = 0,
    flatbuffers::Offset<flatbuffers::String> uuid = 0) {
  ServiceBuilder builder_(_fbb);
  builder_.add_uuid(uuid);
  builder_.add_group_end_handle(group_end_handle);
  builder_.add_handle(handle);
  return builder_.Finish();
}

inline flatbuffers::Offset<Service> CreateServiceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t handle = 0,
    uint16_t group_end_handle = 0,
    const char *uuid = nullptr) {
  return BaBLE::CreateService(
      _fbb,
      handle,
      group_end_handle,
      uuid ? _fbb.CreateString(uuid) : 0);
}

struct ProbeServices FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CONNECTION_HANDLE = 4,
    VT_SERVICES = 6
  };
  uint16_t connection_handle() const {
    return GetField<uint16_t>(VT_CONNECTION_HANDLE, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Service>> *services() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Service>> *>(VT_SERVICES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_CONNECTION_HANDLE) &&
           VerifyOffset(verifier, VT_SERVICES) &&
           verifier.Verify(services()) &&
           verifier.VerifyVectorOfTables(services()) &&
           verifier.EndTable();
  }
};

struct ProbeServicesBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_connection_handle(uint16_t connection_handle) {
    fbb_.AddElement<uint16_t>(ProbeServices::VT_CONNECTION_HANDLE, connection_handle, 0);
  }
  void add_services(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Service>>> services) {
    fbb_.AddOffset(ProbeServices::VT_SERVICES, services);
  }
  explicit ProbeServicesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ProbeServicesBuilder &operator=(const ProbeServicesBuilder &);
  flatbuffers::Offset<ProbeServices> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ProbeServices>(end);
    return o;
  }
};

inline flatbuffers::Offset<ProbeServices> CreateProbeServices(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t connection_handle = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Service>>> services = 0) {
  ProbeServicesBuilder builder_(_fbb);
  builder_.add_services(services);
  builder_.add_connection_handle(connection_handle);
  return builder_.Finish();
}

inline flatbuffers::Offset<ProbeServices> CreateProbeServicesDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t connection_handle = 0,
    const std::vector<flatbuffers::Offset<Service>> *services = nullptr) {
  return BaBLE::CreateProbeServices(
      _fbb,
      connection_handle,
      services ? _fbb.CreateVector<flatbuffers::Offset<Service>>(*services) : 0);
}

struct Characteristic FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_HANDLE = 4,
    VT_VALUE_HANDLE = 6,
    VT_INDICATE = 8,
    VT_NOTIFY = 10,
    VT_WRITE = 12,
    VT_READ = 14,
    VT_BROADCAST = 16,
    VT_UUID = 18
  };
  uint16_t handle() const {
    return GetField<uint16_t>(VT_HANDLE, 0);
  }
  uint16_t value_handle() const {
    return GetField<uint16_t>(VT_VALUE_HANDLE, 0);
  }
  bool indicate() const {
    return GetField<uint8_t>(VT_INDICATE, 0) != 0;
  }
  bool notify() const {
    return GetField<uint8_t>(VT_NOTIFY, 0) != 0;
  }
  bool write() const {
    return GetField<uint8_t>(VT_WRITE, 0) != 0;
  }
  bool read() const {
    return GetField<uint8_t>(VT_READ, 0) != 0;
  }
  bool broadcast() const {
    return GetField<uint8_t>(VT_BROADCAST, 0) != 0;
  }
  const flatbuffers::String *uuid() const {
    return GetPointer<const flatbuffers::String *>(VT_UUID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_HANDLE) &&
           VerifyField<uint16_t>(verifier, VT_VALUE_HANDLE) &&
           VerifyField<uint8_t>(verifier, VT_INDICATE) &&
           VerifyField<uint8_t>(verifier, VT_NOTIFY) &&
           VerifyField<uint8_t>(verifier, VT_WRITE) &&
           VerifyField<uint8_t>(verifier, VT_READ) &&
           VerifyField<uint8_t>(verifier, VT_BROADCAST) &&
           VerifyOffset(verifier, VT_UUID) &&
           verifier.Verify(uuid()) &&
           verifier.EndTable();
  }
};

struct CharacteristicBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_handle(uint16_t handle) {
    fbb_.AddElement<uint16_t>(Characteristic::VT_HANDLE, handle, 0);
  }
  void add_value_handle(uint16_t value_handle) {
    fbb_.AddElement<uint16_t>(Characteristic::VT_VALUE_HANDLE, value_handle, 0);
  }
  void add_indicate(bool indicate) {
    fbb_.AddElement<uint8_t>(Characteristic::VT_INDICATE, static_cast<uint8_t>(indicate), 0);
  }
  void add_notify(bool notify) {
    fbb_.AddElement<uint8_t>(Characteristic::VT_NOTIFY, static_cast<uint8_t>(notify), 0);
  }
  void add_write(bool write) {
    fbb_.AddElement<uint8_t>(Characteristic::VT_WRITE, static_cast<uint8_t>(write), 0);
  }
  void add_read(bool read) {
    fbb_.AddElement<uint8_t>(Characteristic::VT_READ, static_cast<uint8_t>(read), 0);
  }
  void add_broadcast(bool broadcast) {
    fbb_.AddElement<uint8_t>(Characteristic::VT_BROADCAST, static_cast<uint8_t>(broadcast), 0);
  }
  void add_uuid(flatbuffers::Offset<flatbuffers::String> uuid) {
    fbb_.AddOffset(Characteristic::VT_UUID, uuid);
  }
  explicit CharacteristicBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CharacteristicBuilder &operator=(const CharacteristicBuilder &);
  flatbuffers::Offset<Characteristic> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Characteristic>(end);
    return o;
  }
};

inline flatbuffers::Offset<Characteristic> CreateCharacteristic(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t handle = 0,
    uint16_t value_handle = 0,
    bool indicate = false,
    bool notify = false,
    bool write = false,
    bool read = false,
    bool broadcast = false,
    flatbuffers::Offset<flatbuffers::String> uuid = 0) {
  CharacteristicBuilder builder_(_fbb);
  builder_.add_uuid(uuid);
  builder_.add_value_handle(value_handle);
  builder_.add_handle(handle);
  builder_.add_broadcast(broadcast);
  builder_.add_read(read);
  builder_.add_write(write);
  builder_.add_notify(notify);
  builder_.add_indicate(indicate);
  return builder_.Finish();
}

inline flatbuffers::Offset<Characteristic> CreateCharacteristicDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t handle = 0,
    uint16_t value_handle = 0,
    bool indicate = false,
    bool notify = false,
    bool write = false,
    bool read = false,
    bool broadcast = false,
    const char *uuid = nullptr) {
  return BaBLE::CreateCharacteristic(
      _fbb,
      handle,
      value_handle,
      indicate,
      notify,
      write,
      read,
      broadcast,
      uuid ? _fbb.CreateString(uuid) : 0);
}

struct ProbeCharacteristics FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CONNECTION_HANDLE = 4,
    VT_CHARACTERISTICS = 6
  };
  uint16_t connection_handle() const {
    return GetField<uint16_t>(VT_CONNECTION_HANDLE, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Characteristic>> *characteristics() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Characteristic>> *>(VT_CHARACTERISTICS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_CONNECTION_HANDLE) &&
           VerifyOffset(verifier, VT_CHARACTERISTICS) &&
           verifier.Verify(characteristics()) &&
           verifier.VerifyVectorOfTables(characteristics()) &&
           verifier.EndTable();
  }
};

struct ProbeCharacteristicsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_connection_handle(uint16_t connection_handle) {
    fbb_.AddElement<uint16_t>(ProbeCharacteristics::VT_CONNECTION_HANDLE, connection_handle, 0);
  }
  void add_characteristics(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Characteristic>>> characteristics) {
    fbb_.AddOffset(ProbeCharacteristics::VT_CHARACTERISTICS, characteristics);
  }
  explicit ProbeCharacteristicsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ProbeCharacteristicsBuilder &operator=(const ProbeCharacteristicsBuilder &);
  flatbuffers::Offset<ProbeCharacteristics> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ProbeCharacteristics>(end);
    return o;
  }
};

inline flatbuffers::Offset<ProbeCharacteristics> CreateProbeCharacteristics(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t connection_handle = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Characteristic>>> characteristics = 0) {
  ProbeCharacteristicsBuilder builder_(_fbb);
  builder_.add_characteristics(characteristics);
  builder_.add_connection_handle(connection_handle);
  return builder_.Finish();
}

inline flatbuffers::Offset<ProbeCharacteristics> CreateProbeCharacteristicsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t connection_handle = 0,
    const std::vector<flatbuffers::Offset<Characteristic>> *characteristics = nullptr) {
  return BaBLE::CreateProbeCharacteristics(
      _fbb,
      connection_handle,
      characteristics ? _fbb.CreateVector<flatbuffers::Offset<Characteristic>>(*characteristics) : 0);
}

struct DeviceConnected FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CONNECTION_HANDLE = 4,
    VT_ADDRESS = 6,
    VT_ADDRESS_TYPE = 8,
    VT_FLAGS = 10,
    VT_UUID = 12,
    VT_COMPANY_ID = 14,
    VT_DEVICE_NAME = 16
  };
  uint16_t connection_handle() const {
    return GetField<uint16_t>(VT_CONNECTION_HANDLE, 0);
  }
  const flatbuffers::String *address() const {
    return GetPointer<const flatbuffers::String *>(VT_ADDRESS);
  }
  uint8_t address_type() const {
    return GetField<uint8_t>(VT_ADDRESS_TYPE, 0);
  }
  const flatbuffers::Vector<uint8_t> *flags() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_FLAGS);
  }
  const flatbuffers::String *uuid() const {
    return GetPointer<const flatbuffers::String *>(VT_UUID);
  }
  uint16_t company_id() const {
    return GetField<uint16_t>(VT_COMPANY_ID, 0);
  }
  const flatbuffers::String *device_name() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICE_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_CONNECTION_HANDLE) &&
           VerifyOffset(verifier, VT_ADDRESS) &&
           verifier.Verify(address()) &&
           VerifyField<uint8_t>(verifier, VT_ADDRESS_TYPE) &&
           VerifyOffset(verifier, VT_FLAGS) &&
           verifier.Verify(flags()) &&
           VerifyOffset(verifier, VT_UUID) &&
           verifier.Verify(uuid()) &&
           VerifyField<uint16_t>(verifier, VT_COMPANY_ID) &&
           VerifyOffset(verifier, VT_DEVICE_NAME) &&
           verifier.Verify(device_name()) &&
           verifier.EndTable();
  }
};

struct DeviceConnectedBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_connection_handle(uint16_t connection_handle) {
    fbb_.AddElement<uint16_t>(DeviceConnected::VT_CONNECTION_HANDLE, connection_handle, 0);
  }
  void add_address(flatbuffers::Offset<flatbuffers::String> address) {
    fbb_.AddOffset(DeviceConnected::VT_ADDRESS, address);
  }
  void add_address_type(uint8_t address_type) {
    fbb_.AddElement<uint8_t>(DeviceConnected::VT_ADDRESS_TYPE, address_type, 0);
  }
  void add_flags(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> flags) {
    fbb_.AddOffset(DeviceConnected::VT_FLAGS, flags);
  }
  void add_uuid(flatbuffers::Offset<flatbuffers::String> uuid) {
    fbb_.AddOffset(DeviceConnected::VT_UUID, uuid);
  }
  void add_company_id(uint16_t company_id) {
    fbb_.AddElement<uint16_t>(DeviceConnected::VT_COMPANY_ID, company_id, 0);
  }
  void add_device_name(flatbuffers::Offset<flatbuffers::String> device_name) {
    fbb_.AddOffset(DeviceConnected::VT_DEVICE_NAME, device_name);
  }
  explicit DeviceConnectedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DeviceConnectedBuilder &operator=(const DeviceConnectedBuilder &);
  flatbuffers::Offset<DeviceConnected> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DeviceConnected>(end);
    return o;
  }
};

inline flatbuffers::Offset<DeviceConnected> CreateDeviceConnected(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t connection_handle = 0,
    flatbuffers::Offset<flatbuffers::String> address = 0,
    uint8_t address_type = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> flags = 0,
    flatbuffers::Offset<flatbuffers::String> uuid = 0,
    uint16_t company_id = 0,
    flatbuffers::Offset<flatbuffers::String> device_name = 0) {
  DeviceConnectedBuilder builder_(_fbb);
  builder_.add_device_name(device_name);
  builder_.add_uuid(uuid);
  builder_.add_flags(flags);
  builder_.add_address(address);
  builder_.add_company_id(company_id);
  builder_.add_connection_handle(connection_handle);
  builder_.add_address_type(address_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<DeviceConnected> CreateDeviceConnectedDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t connection_handle = 0,
    const char *address = nullptr,
    uint8_t address_type = 0,
    const std::vector<uint8_t> *flags = nullptr,
    const char *uuid = nullptr,
    uint16_t company_id = 0,
    const char *device_name = nullptr) {
  return BaBLE::CreateDeviceConnected(
      _fbb,
      connection_handle,
      address ? _fbb.CreateString(address) : 0,
      address_type,
      flags ? _fbb.CreateVector<uint8_t>(*flags) : 0,
      uuid ? _fbb.CreateString(uuid) : 0,
      company_id,
      device_name ? _fbb.CreateString(device_name) : 0);
}

struct DeviceDisconnected FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CONNECTION_HANDLE = 4,
    VT_ADDRESS = 6,
    VT_ADDRESS_TYPE = 8,
    VT_REASON = 10
  };
  uint16_t connection_handle() const {
    return GetField<uint16_t>(VT_CONNECTION_HANDLE, 0);
  }
  const flatbuffers::String *address() const {
    return GetPointer<const flatbuffers::String *>(VT_ADDRESS);
  }
  uint8_t address_type() const {
    return GetField<uint8_t>(VT_ADDRESS_TYPE, 0);
  }
  const flatbuffers::String *reason() const {
    return GetPointer<const flatbuffers::String *>(VT_REASON);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_CONNECTION_HANDLE) &&
           VerifyOffset(verifier, VT_ADDRESS) &&
           verifier.Verify(address()) &&
           VerifyField<uint8_t>(verifier, VT_ADDRESS_TYPE) &&
           VerifyOffset(verifier, VT_REASON) &&
           verifier.Verify(reason()) &&
           verifier.EndTable();
  }
};

struct DeviceDisconnectedBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_connection_handle(uint16_t connection_handle) {
    fbb_.AddElement<uint16_t>(DeviceDisconnected::VT_CONNECTION_HANDLE, connection_handle, 0);
  }
  void add_address(flatbuffers::Offset<flatbuffers::String> address) {
    fbb_.AddOffset(DeviceDisconnected::VT_ADDRESS, address);
  }
  void add_address_type(uint8_t address_type) {
    fbb_.AddElement<uint8_t>(DeviceDisconnected::VT_ADDRESS_TYPE, address_type, 0);
  }
  void add_reason(flatbuffers::Offset<flatbuffers::String> reason) {
    fbb_.AddOffset(DeviceDisconnected::VT_REASON, reason);
  }
  explicit DeviceDisconnectedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DeviceDisconnectedBuilder &operator=(const DeviceDisconnectedBuilder &);
  flatbuffers::Offset<DeviceDisconnected> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DeviceDisconnected>(end);
    return o;
  }
};

inline flatbuffers::Offset<DeviceDisconnected> CreateDeviceDisconnected(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t connection_handle = 0,
    flatbuffers::Offset<flatbuffers::String> address = 0,
    uint8_t address_type = 0,
    flatbuffers::Offset<flatbuffers::String> reason = 0) {
  DeviceDisconnectedBuilder builder_(_fbb);
  builder_.add_reason(reason);
  builder_.add_address(address);
  builder_.add_connection_handle(connection_handle);
  builder_.add_address_type(address_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<DeviceDisconnected> CreateDeviceDisconnectedDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t connection_handle = 0,
    const char *address = nullptr,
    uint8_t address_type = 0,
    const char *reason = nullptr) {
  return BaBLE::CreateDeviceDisconnected(
      _fbb,
      connection_handle,
      address ? _fbb.CreateString(address) : 0,
      address_type,
      reason ? _fbb.CreateString(reason) : 0);
}

struct DeviceFound FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ADDRESS = 4,
    VT_ADDRESS_TYPE = 6,
    VT_RSSI = 8,
    VT_FLAGS = 10,
    VT_UUID = 12,
    VT_COMPANY_ID = 14,
    VT_DEVICE_NAME = 16
  };
  const flatbuffers::String *address() const {
    return GetPointer<const flatbuffers::String *>(VT_ADDRESS);
  }
  uint8_t address_type() const {
    return GetField<uint8_t>(VT_ADDRESS_TYPE, 0);
  }
  int8_t rssi() const {
    return GetField<int8_t>(VT_RSSI, 0);
  }
  const flatbuffers::Vector<uint8_t> *flags() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_FLAGS);
  }
  const flatbuffers::String *uuid() const {
    return GetPointer<const flatbuffers::String *>(VT_UUID);
  }
  uint16_t company_id() const {
    return GetField<uint16_t>(VT_COMPANY_ID, 0);
  }
  const flatbuffers::String *device_name() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICE_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ADDRESS) &&
           verifier.Verify(address()) &&
           VerifyField<uint8_t>(verifier, VT_ADDRESS_TYPE) &&
           VerifyField<int8_t>(verifier, VT_RSSI) &&
           VerifyOffset(verifier, VT_FLAGS) &&
           verifier.Verify(flags()) &&
           VerifyOffset(verifier, VT_UUID) &&
           verifier.Verify(uuid()) &&
           VerifyField<uint16_t>(verifier, VT_COMPANY_ID) &&
           VerifyOffset(verifier, VT_DEVICE_NAME) &&
           verifier.Verify(device_name()) &&
           verifier.EndTable();
  }
};

struct DeviceFoundBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_address(flatbuffers::Offset<flatbuffers::String> address) {
    fbb_.AddOffset(DeviceFound::VT_ADDRESS, address);
  }
  void add_address_type(uint8_t address_type) {
    fbb_.AddElement<uint8_t>(DeviceFound::VT_ADDRESS_TYPE, address_type, 0);
  }
  void add_rssi(int8_t rssi) {
    fbb_.AddElement<int8_t>(DeviceFound::VT_RSSI, rssi, 0);
  }
  void add_flags(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> flags) {
    fbb_.AddOffset(DeviceFound::VT_FLAGS, flags);
  }
  void add_uuid(flatbuffers::Offset<flatbuffers::String> uuid) {
    fbb_.AddOffset(DeviceFound::VT_UUID, uuid);
  }
  void add_company_id(uint16_t company_id) {
    fbb_.AddElement<uint16_t>(DeviceFound::VT_COMPANY_ID, company_id, 0);
  }
  void add_device_name(flatbuffers::Offset<flatbuffers::String> device_name) {
    fbb_.AddOffset(DeviceFound::VT_DEVICE_NAME, device_name);
  }
  explicit DeviceFoundBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DeviceFoundBuilder &operator=(const DeviceFoundBuilder &);
  flatbuffers::Offset<DeviceFound> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DeviceFound>(end);
    return o;
  }
};

inline flatbuffers::Offset<DeviceFound> CreateDeviceFound(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> address = 0,
    uint8_t address_type = 0,
    int8_t rssi = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> flags = 0,
    flatbuffers::Offset<flatbuffers::String> uuid = 0,
    uint16_t company_id = 0,
    flatbuffers::Offset<flatbuffers::String> device_name = 0) {
  DeviceFoundBuilder builder_(_fbb);
  builder_.add_device_name(device_name);
  builder_.add_uuid(uuid);
  builder_.add_flags(flags);
  builder_.add_address(address);
  builder_.add_company_id(company_id);
  builder_.add_rssi(rssi);
  builder_.add_address_type(address_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<DeviceFound> CreateDeviceFoundDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *address = nullptr,
    uint8_t address_type = 0,
    int8_t rssi = 0,
    const std::vector<uint8_t> *flags = nullptr,
    const char *uuid = nullptr,
    uint16_t company_id = 0,
    const char *device_name = nullptr) {
  return BaBLE::CreateDeviceFound(
      _fbb,
      address ? _fbb.CreateString(address) : 0,
      address_type,
      rssi,
      flags ? _fbb.CreateVector<uint8_t>(*flags) : 0,
      uuid ? _fbb.CreateString(uuid) : 0,
      company_id,
      device_name ? _fbb.CreateString(device_name) : 0);
}

struct Discovering FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ADDRESS_TYPE = 4,
    VT_STATE = 6
  };
  uint8_t address_type() const {
    return GetField<uint8_t>(VT_ADDRESS_TYPE, 0);
  }
  bool state() const {
    return GetField<uint8_t>(VT_STATE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ADDRESS_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_STATE) &&
           verifier.EndTable();
  }
};

struct DiscoveringBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_address_type(uint8_t address_type) {
    fbb_.AddElement<uint8_t>(Discovering::VT_ADDRESS_TYPE, address_type, 0);
  }
  void add_state(bool state) {
    fbb_.AddElement<uint8_t>(Discovering::VT_STATE, static_cast<uint8_t>(state), 0);
  }
  explicit DiscoveringBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DiscoveringBuilder &operator=(const DiscoveringBuilder &);
  flatbuffers::Offset<Discovering> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Discovering>(end);
    return o;
  }
};

inline flatbuffers::Offset<Discovering> CreateDiscovering(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t address_type = 0,
    bool state = false) {
  DiscoveringBuilder builder_(_fbb);
  builder_.add_state(state);
  builder_.add_address_type(address_type);
  return builder_.Finish();
}

struct ControllerAdded FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ControllerAddedBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ControllerAddedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ControllerAddedBuilder &operator=(const ControllerAddedBuilder &);
  flatbuffers::Offset<ControllerAdded> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ControllerAdded>(end);
    return o;
  }
};

inline flatbuffers::Offset<ControllerAdded> CreateControllerAdded(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ControllerAddedBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ControllerRemoved FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ControllerRemovedBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ControllerRemovedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ControllerRemovedBuilder &operator=(const ControllerRemovedBuilder &);
  flatbuffers::Offset<ControllerRemoved> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ControllerRemoved>(end);
    return o;
  }
};

inline flatbuffers::Offset<ControllerRemoved> CreateControllerRemoved(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ControllerRemovedBuilder builder_(_fbb);
  return builder_.Finish();
}

struct NotificationReceived FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CONNECTION_HANDLE = 4,
    VT_ATTRIBUTE_HANDLE = 6,
    VT_VALUE = 8
  };
  uint16_t connection_handle() const {
    return GetField<uint16_t>(VT_CONNECTION_HANDLE, 0);
  }
  const flatbuffers::String *attribute_handle() const {
    return GetPointer<const flatbuffers::String *>(VT_ATTRIBUTE_HANDLE);
  }
  const flatbuffers::Vector<uint8_t> *value() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_CONNECTION_HANDLE) &&
           VerifyOffset(verifier, VT_ATTRIBUTE_HANDLE) &&
           verifier.Verify(attribute_handle()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.Verify(value()) &&
           verifier.EndTable();
  }
};

struct NotificationReceivedBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_connection_handle(uint16_t connection_handle) {
    fbb_.AddElement<uint16_t>(NotificationReceived::VT_CONNECTION_HANDLE, connection_handle, 0);
  }
  void add_attribute_handle(flatbuffers::Offset<flatbuffers::String> attribute_handle) {
    fbb_.AddOffset(NotificationReceived::VT_ATTRIBUTE_HANDLE, attribute_handle);
  }
  void add_value(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value) {
    fbb_.AddOffset(NotificationReceived::VT_VALUE, value);
  }
  explicit NotificationReceivedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NotificationReceivedBuilder &operator=(const NotificationReceivedBuilder &);
  flatbuffers::Offset<NotificationReceived> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NotificationReceived>(end);
    return o;
  }
};

inline flatbuffers::Offset<NotificationReceived> CreateNotificationReceived(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t connection_handle = 0,
    flatbuffers::Offset<flatbuffers::String> attribute_handle = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value = 0) {
  NotificationReceivedBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_attribute_handle(attribute_handle);
  builder_.add_connection_handle(connection_handle);
  return builder_.Finish();
}

inline flatbuffers::Offset<NotificationReceived> CreateNotificationReceivedDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t connection_handle = 0,
    const char *attribute_handle = nullptr,
    const std::vector<uint8_t> *value = nullptr) {
  return BaBLE::CreateNotificationReceived(
      _fbb,
      connection_handle,
      attribute_handle ? _fbb.CreateString(attribute_handle) : 0,
      value ? _fbb.CreateVector<uint8_t>(*value) : 0);
}

struct BaBLEError FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MESSAGE = 4
  };
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.Verify(message()) &&
           verifier.EndTable();
  }
};

struct BaBLEErrorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(BaBLEError::VT_MESSAGE, message);
  }
  explicit BaBLEErrorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BaBLEErrorBuilder &operator=(const BaBLEErrorBuilder &);
  flatbuffers::Offset<BaBLEError> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BaBLEError>(end);
    return o;
  }
};

inline flatbuffers::Offset<BaBLEError> CreateBaBLEError(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> message = 0) {
  BaBLEErrorBuilder builder_(_fbb);
  builder_.add_message(message);
  return builder_.Finish();
}

inline flatbuffers::Offset<BaBLEError> CreateBaBLEErrorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *message = nullptr) {
  return BaBLE::CreateBaBLEError(
      _fbb,
      message ? _fbb.CreateString(message) : 0);
}

struct Ready FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ReadyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ReadyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReadyBuilder &operator=(const ReadyBuilder &);
  flatbuffers::Offset<Ready> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Ready>(end);
    return o;
  }
};

inline flatbuffers::Offset<Ready> CreateReady(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ReadyBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Exit FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ExitBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ExitBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ExitBuilder &operator=(const ExitBuilder &);
  flatbuffers::Offset<Exit> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Exit>(end);
    return o;
  }
};

inline flatbuffers::Offset<Exit> CreateExit(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ExitBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Packet FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_UUID = 4,
    VT_PAYLOAD_TYPE = 6,
    VT_PAYLOAD = 8,
    VT_CONTROLLER_ID = 10,
    VT_STATUS = 12,
    VT_NATIVE_STATUS = 14,
    VT_NATIVE_CLASS = 16
  };
  const flatbuffers::String *uuid() const {
    return GetPointer<const flatbuffers::String *>(VT_UUID);
  }
  Payload payload_type() const {
    return static_cast<Payload>(GetField<uint8_t>(VT_PAYLOAD_TYPE, 0));
  }
  const void *payload() const {
    return GetPointer<const void *>(VT_PAYLOAD);
  }
  template<typename T> const T *payload_as() const;
  const AddDevice *payload_as_AddDevice() const {
    return payload_type() == Payload::AddDevice ? static_cast<const AddDevice *>(payload()) : nullptr;
  }
  const Disconnect *payload_as_Disconnect() const {
    return payload_type() == Payload::Disconnect ? static_cast<const Disconnect *>(payload()) : nullptr;
  }
  const GetConnectedDevices *payload_as_GetConnectedDevices() const {
    return payload_type() == Payload::GetConnectedDevices ? static_cast<const GetConnectedDevices *>(payload()) : nullptr;
  }
  const GetControllersIds *payload_as_GetControllersIds() const {
    return payload_type() == Payload::GetControllersIds ? static_cast<const GetControllersIds *>(payload()) : nullptr;
  }
  const GetControllerInfo *payload_as_GetControllerInfo() const {
    return payload_type() == Payload::GetControllerInfo ? static_cast<const GetControllerInfo *>(payload()) : nullptr;
  }
  const GetControllersList *payload_as_GetControllersList() const {
    return payload_type() == Payload::GetControllersList ? static_cast<const GetControllersList *>(payload()) : nullptr;
  }
  const GetMGMTInfo *payload_as_GetMGMTInfo() const {
    return payload_type() == Payload::GetMGMTInfo ? static_cast<const GetMGMTInfo *>(payload()) : nullptr;
  }
  const ProbeCharacteristics *payload_as_ProbeCharacteristics() const {
    return payload_type() == Payload::ProbeCharacteristics ? static_cast<const ProbeCharacteristics *>(payload()) : nullptr;
  }
  const ProbeServices *payload_as_ProbeServices() const {
    return payload_type() == Payload::ProbeServices ? static_cast<const ProbeServices *>(payload()) : nullptr;
  }
  const Read *payload_as_Read() const {
    return payload_type() == Payload::Read ? static_cast<const Read *>(payload()) : nullptr;
  }
  const RemoveDevice *payload_as_RemoveDevice() const {
    return payload_type() == Payload::RemoveDevice ? static_cast<const RemoveDevice *>(payload()) : nullptr;
  }
  const SetConnectable *payload_as_SetConnectable() const {
    return payload_type() == Payload::SetConnectable ? static_cast<const SetConnectable *>(payload()) : nullptr;
  }
  const SetDiscoverable *payload_as_SetDiscoverable() const {
    return payload_type() == Payload::SetDiscoverable ? static_cast<const SetDiscoverable *>(payload()) : nullptr;
  }
  const SetPowered *payload_as_SetPowered() const {
    return payload_type() == Payload::SetPowered ? static_cast<const SetPowered *>(payload()) : nullptr;
  }
  const StartScan *payload_as_StartScan() const {
    return payload_type() == Payload::StartScan ? static_cast<const StartScan *>(payload()) : nullptr;
  }
  const StopScan *payload_as_StopScan() const {
    return payload_type() == Payload::StopScan ? static_cast<const StopScan *>(payload()) : nullptr;
  }
  const Write *payload_as_Write() const {
    return payload_type() == Payload::Write ? static_cast<const Write *>(payload()) : nullptr;
  }
  const WriteWithoutResponse *payload_as_WriteWithoutResponse() const {
    return payload_type() == Payload::WriteWithoutResponse ? static_cast<const WriteWithoutResponse *>(payload()) : nullptr;
  }
  const ControllerAdded *payload_as_ControllerAdded() const {
    return payload_type() == Payload::ControllerAdded ? static_cast<const ControllerAdded *>(payload()) : nullptr;
  }
  const ControllerRemoved *payload_as_ControllerRemoved() const {
    return payload_type() == Payload::ControllerRemoved ? static_cast<const ControllerRemoved *>(payload()) : nullptr;
  }
  const DeviceConnected *payload_as_DeviceConnected() const {
    return payload_type() == Payload::DeviceConnected ? static_cast<const DeviceConnected *>(payload()) : nullptr;
  }
  const DeviceDisconnected *payload_as_DeviceDisconnected() const {
    return payload_type() == Payload::DeviceDisconnected ? static_cast<const DeviceDisconnected *>(payload()) : nullptr;
  }
  const DeviceFound *payload_as_DeviceFound() const {
    return payload_type() == Payload::DeviceFound ? static_cast<const DeviceFound *>(payload()) : nullptr;
  }
  const Discovering *payload_as_Discovering() const {
    return payload_type() == Payload::Discovering ? static_cast<const Discovering *>(payload()) : nullptr;
  }
  const NotificationReceived *payload_as_NotificationReceived() const {
    return payload_type() == Payload::NotificationReceived ? static_cast<const NotificationReceived *>(payload()) : nullptr;
  }
  const BaBLEError *payload_as_BaBLEError() const {
    return payload_type() == Payload::BaBLEError ? static_cast<const BaBLEError *>(payload()) : nullptr;
  }
  const Exit *payload_as_Exit() const {
    return payload_type() == Payload::Exit ? static_cast<const Exit *>(payload()) : nullptr;
  }
  const Ready *payload_as_Ready() const {
    return payload_type() == Payload::Ready ? static_cast<const Ready *>(payload()) : nullptr;
  }
  uint16_t controller_id() const {
    return GetField<uint16_t>(VT_CONTROLLER_ID, 65535);
  }
  StatusCode status() const {
    return static_cast<StatusCode>(GetField<uint8_t>(VT_STATUS, 0));
  }
  uint8_t native_status() const {
    return GetField<uint8_t>(VT_NATIVE_STATUS, 0);
  }
  const flatbuffers::String *native_class() const {
    return GetPointer<const flatbuffers::String *>(VT_NATIVE_CLASS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_UUID) &&
           verifier.Verify(uuid()) &&
           VerifyField<uint8_t>(verifier, VT_PAYLOAD_TYPE) &&
           VerifyOffset(verifier, VT_PAYLOAD) &&
           VerifyPayload(verifier, payload(), payload_type()) &&
           VerifyField<uint16_t>(verifier, VT_CONTROLLER_ID) &&
           VerifyField<uint8_t>(verifier, VT_STATUS) &&
           VerifyField<uint8_t>(verifier, VT_NATIVE_STATUS) &&
           VerifyOffset(verifier, VT_NATIVE_CLASS) &&
           verifier.Verify(native_class()) &&
           verifier.EndTable();
  }
};

template<> inline const AddDevice *Packet::payload_as<AddDevice>() const {
  return payload_as_AddDevice();
}

template<> inline const Disconnect *Packet::payload_as<Disconnect>() const {
  return payload_as_Disconnect();
}

template<> inline const GetConnectedDevices *Packet::payload_as<GetConnectedDevices>() const {
  return payload_as_GetConnectedDevices();
}

template<> inline const GetControllersIds *Packet::payload_as<GetControllersIds>() const {
  return payload_as_GetControllersIds();
}

template<> inline const GetControllerInfo *Packet::payload_as<GetControllerInfo>() const {
  return payload_as_GetControllerInfo();
}

template<> inline const GetControllersList *Packet::payload_as<GetControllersList>() const {
  return payload_as_GetControllersList();
}

template<> inline const GetMGMTInfo *Packet::payload_as<GetMGMTInfo>() const {
  return payload_as_GetMGMTInfo();
}

template<> inline const ProbeCharacteristics *Packet::payload_as<ProbeCharacteristics>() const {
  return payload_as_ProbeCharacteristics();
}

template<> inline const ProbeServices *Packet::payload_as<ProbeServices>() const {
  return payload_as_ProbeServices();
}

template<> inline const Read *Packet::payload_as<Read>() const {
  return payload_as_Read();
}

template<> inline const RemoveDevice *Packet::payload_as<RemoveDevice>() const {
  return payload_as_RemoveDevice();
}

template<> inline const SetConnectable *Packet::payload_as<SetConnectable>() const {
  return payload_as_SetConnectable();
}

template<> inline const SetDiscoverable *Packet::payload_as<SetDiscoverable>() const {
  return payload_as_SetDiscoverable();
}

template<> inline const SetPowered *Packet::payload_as<SetPowered>() const {
  return payload_as_SetPowered();
}

template<> inline const StartScan *Packet::payload_as<StartScan>() const {
  return payload_as_StartScan();
}

template<> inline const StopScan *Packet::payload_as<StopScan>() const {
  return payload_as_StopScan();
}

template<> inline const Write *Packet::payload_as<Write>() const {
  return payload_as_Write();
}

template<> inline const WriteWithoutResponse *Packet::payload_as<WriteWithoutResponse>() const {
  return payload_as_WriteWithoutResponse();
}

template<> inline const ControllerAdded *Packet::payload_as<ControllerAdded>() const {
  return payload_as_ControllerAdded();
}

template<> inline const ControllerRemoved *Packet::payload_as<ControllerRemoved>() const {
  return payload_as_ControllerRemoved();
}

template<> inline const DeviceConnected *Packet::payload_as<DeviceConnected>() const {
  return payload_as_DeviceConnected();
}

template<> inline const DeviceDisconnected *Packet::payload_as<DeviceDisconnected>() const {
  return payload_as_DeviceDisconnected();
}

template<> inline const DeviceFound *Packet::payload_as<DeviceFound>() const {
  return payload_as_DeviceFound();
}

template<> inline const Discovering *Packet::payload_as<Discovering>() const {
  return payload_as_Discovering();
}

template<> inline const NotificationReceived *Packet::payload_as<NotificationReceived>() const {
  return payload_as_NotificationReceived();
}

template<> inline const BaBLEError *Packet::payload_as<BaBLEError>() const {
  return payload_as_BaBLEError();
}

template<> inline const Exit *Packet::payload_as<Exit>() const {
  return payload_as_Exit();
}

template<> inline const Ready *Packet::payload_as<Ready>() const {
  return payload_as_Ready();
}

struct PacketBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_uuid(flatbuffers::Offset<flatbuffers::String> uuid) {
    fbb_.AddOffset(Packet::VT_UUID, uuid);
  }
  void add_payload_type(Payload payload_type) {
    fbb_.AddElement<uint8_t>(Packet::VT_PAYLOAD_TYPE, static_cast<uint8_t>(payload_type), 0);
  }
  void add_payload(flatbuffers::Offset<void> payload) {
    fbb_.AddOffset(Packet::VT_PAYLOAD, payload);
  }
  void add_controller_id(uint16_t controller_id) {
    fbb_.AddElement<uint16_t>(Packet::VT_CONTROLLER_ID, controller_id, 65535);
  }
  void add_status(StatusCode status) {
    fbb_.AddElement<uint8_t>(Packet::VT_STATUS, static_cast<uint8_t>(status), 0);
  }
  void add_native_status(uint8_t native_status) {
    fbb_.AddElement<uint8_t>(Packet::VT_NATIVE_STATUS, native_status, 0);
  }
  void add_native_class(flatbuffers::Offset<flatbuffers::String> native_class) {
    fbb_.AddOffset(Packet::VT_NATIVE_CLASS, native_class);
  }
  explicit PacketBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PacketBuilder &operator=(const PacketBuilder &);
  flatbuffers::Offset<Packet> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Packet>(end);
    return o;
  }
};

inline flatbuffers::Offset<Packet> CreatePacket(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> uuid = 0,
    Payload payload_type = Payload::NONE,
    flatbuffers::Offset<void> payload = 0,
    uint16_t controller_id = 65535,
    StatusCode status = StatusCode::Success,
    uint8_t native_status = 0,
    flatbuffers::Offset<flatbuffers::String> native_class = 0) {
  PacketBuilder builder_(_fbb);
  builder_.add_native_class(native_class);
  builder_.add_payload(payload);
  builder_.add_uuid(uuid);
  builder_.add_controller_id(controller_id);
  builder_.add_native_status(native_status);
  builder_.add_status(status);
  builder_.add_payload_type(payload_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Packet> CreatePacketDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *uuid = nullptr,
    Payload payload_type = Payload::NONE,
    flatbuffers::Offset<void> payload = 0,
    uint16_t controller_id = 65535,
    StatusCode status = StatusCode::Success,
    uint8_t native_status = 0,
    const char *native_class = nullptr) {
  return BaBLE::CreatePacket(
      _fbb,
      uuid ? _fbb.CreateString(uuid) : 0,
      payload_type,
      payload,
      controller_id,
      status,
      native_status,
      native_class ? _fbb.CreateString(native_class) : 0);
}

inline bool VerifyPayload(flatbuffers::Verifier &verifier, const void *obj, Payload type) {
  switch (type) {
    case Payload::NONE: {
      return true;
    }
    case Payload::AddDevice: {
      auto ptr = reinterpret_cast<const AddDevice *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::Disconnect: {
      auto ptr = reinterpret_cast<const Disconnect *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::GetConnectedDevices: {
      auto ptr = reinterpret_cast<const GetConnectedDevices *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::GetControllersIds: {
      auto ptr = reinterpret_cast<const GetControllersIds *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::GetControllerInfo: {
      auto ptr = reinterpret_cast<const GetControllerInfo *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::GetControllersList: {
      auto ptr = reinterpret_cast<const GetControllersList *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::GetMGMTInfo: {
      auto ptr = reinterpret_cast<const GetMGMTInfo *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::ProbeCharacteristics: {
      auto ptr = reinterpret_cast<const ProbeCharacteristics *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::ProbeServices: {
      auto ptr = reinterpret_cast<const ProbeServices *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::Read: {
      auto ptr = reinterpret_cast<const Read *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::RemoveDevice: {
      auto ptr = reinterpret_cast<const RemoveDevice *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::SetConnectable: {
      auto ptr = reinterpret_cast<const SetConnectable *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::SetDiscoverable: {
      auto ptr = reinterpret_cast<const SetDiscoverable *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::SetPowered: {
      auto ptr = reinterpret_cast<const SetPowered *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::StartScan: {
      auto ptr = reinterpret_cast<const StartScan *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::StopScan: {
      auto ptr = reinterpret_cast<const StopScan *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::Write: {
      auto ptr = reinterpret_cast<const Write *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::WriteWithoutResponse: {
      auto ptr = reinterpret_cast<const WriteWithoutResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::ControllerAdded: {
      auto ptr = reinterpret_cast<const ControllerAdded *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::ControllerRemoved: {
      auto ptr = reinterpret_cast<const ControllerRemoved *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::DeviceConnected: {
      auto ptr = reinterpret_cast<const DeviceConnected *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::DeviceDisconnected: {
      auto ptr = reinterpret_cast<const DeviceDisconnected *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::DeviceFound: {
      auto ptr = reinterpret_cast<const DeviceFound *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::Discovering: {
      auto ptr = reinterpret_cast<const Discovering *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::NotificationReceived: {
      auto ptr = reinterpret_cast<const NotificationReceived *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::BaBLEError: {
      auto ptr = reinterpret_cast<const BaBLEError *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::Exit: {
      auto ptr = reinterpret_cast<const Exit *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::Ready: {
      auto ptr = reinterpret_cast<const Ready *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyPayloadVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyPayload(
        verifier,  values->Get(i), types->GetEnum<Payload>(i))) {
      return false;
    }
  }
  return true;
}

inline const BaBLE::Packet *GetPacket(const void *buf) {
  return flatbuffers::GetRoot<BaBLE::Packet>(buf);
}

inline const BaBLE::Packet *GetSizePrefixedPacket(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<BaBLE::Packet>(buf);
}

inline bool VerifyPacketBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<BaBLE::Packet>(nullptr);
}

inline bool VerifySizePrefixedPacketBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<BaBLE::Packet>(nullptr);
}

inline void FinishPacketBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<BaBLE::Packet> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedPacketBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<BaBLE::Packet> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace BaBLE

#endif  // FLATBUFFERS_GENERATED_PACKET_BABLE_H_
